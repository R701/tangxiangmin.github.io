<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">Vue源码阅读笔记之响应式原理（二）</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/12/10 22:55:42</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>这是”Vue源码阅读笔记”系列第二篇文章。前一篇文章中我们提到<code>initState</code>中调用的<code>initData</code>方法，调用<code>observe(data)</code>完成了对数据的观察。</p>
<p>在很早之前的<a href="/article/对象描述符与响应式数据">对象描述符与响应式数据</a>这篇文章中，对于<code>defineProperty</code>做了简单的整理，并实现了一个比较粗糙的响应式数据更新视图的例子。接下来让我们深入Vue的核心部分：响应式数据的工作原理。</p>
<a id="more"></a>
<p>参考：</p>
<ul>
<li><a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">Vue源码学习</a></li>
<li><a href="https://segmentfault.com/a/1190000008377887" target="_blank" rel="external">Vue原理解析之observer模块</a></li>
<li><a href="http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/" target="_blank" rel="external">Vue2.0 源码阅读：响应式原理</a></li>
</ul>
<p>接下来我们看看Vue中<code>initData</code>是如何实现的响应式数据的。跟前面一样，我们对<code>initData</code>进行简化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> data = vm.$options.data</div><div class="line">  <span class="comment">// 对数据进行代理</span></div><div class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">  <span class="keyword">let</span> i = keys.length</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    <span class="keyword">const</span> key = keys[i]</div><div class="line">    proxy(vm, <span class="string">`_data`</span>, key)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 观察数据变化</span></div><div class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>initData</code>中做了两件事</p>
<ul>
<li>将数据代理到this上</li>
<li>实现响应式数据</li>
</ul>
<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>在Vue中，我们可以通过 <code>this.msg</code> 访问到 <code>this.$data.msg</code>，这是通过数据代理实现的，原理十分简单，即修改对应的getter和setter。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</div><div class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</div><div class="line">  &#125;</div><div class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>[sourceKey][key] = val</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><p>在<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="external">Vue文档</a>中提到了响应式数据的基本原理，稍作整理得到下列结论</p>
<ul>
<li>数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新</li>
<li>如何监听数据的变化呢？所谓监听数据变化，实际上是监听数据某个属性值的变化，Vue使用的是<code>Object.defineProperty</code>。</li>
<li>数据属性值变化时该如何更新视图呢？通过发布-订阅者模式，维护一个订阅该属性值的队列，并在值变化时通知所有订阅者，更新视图</li>
</ul>
<p>其中，<code>Object.defineProperty</code>和订阅者模式在<a href="/article/对象描述符与响应式数据">对象描述符与响应式数据</a>这里已经提到过，这里就不再赘述了，我们来看看Vue中是如何实现的。</p>
<p>在Vue中，由<code>Observer</code>、<code>Dep</code>和<code>Watcher</code>这三个类构成了Vue响应式系统（即<code>observer</code>模块）的核心。<code>observer</code>模块位于<code>/src/core/observer</code>下面。</p>
<p>此处强烈推荐<a href="https://github.com/HcySunYang/observer-dep-watch" target="_blank" rel="external">observer-dep-watch</a>这个项目，相当于一个精简版的响应式系统。下面的源码中，我移除了一些细节代码，这样可以更清晰地了解整个模块的结构。</p>
<p>###Observer</p>
<p><code>Observer</code>用来将数据转换成可监控的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/observer/index.js</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> (value: any) &#123;</div><div class="line">    <span class="keyword">this</span>.value = value</div><div class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="comment">// 数据对象自身的观察者</span></div><div class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</div><div class="line">    <span class="comment">// 需要对数组进行单独处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">      <span class="keyword">const</span> augment = hasProto</div><div class="line">        ? protoAugment</div><div class="line">        : copyAugment</div><div class="line">      augment(value, arrayMethods, arrayKeys)</div><div class="line">      <span class="keyword">this</span>.observeArray(value)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.walk(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code>是数据变化的订阅者，用来执行数据变化之后的某些操作（比如更新视图）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function,</div><div class="line">    cb: Function,</div><div class="line">    options?: ?Object,</div><div class="line">    isRenderWatcher?: boolean</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">this</span>.vm = vm</div><div class="line">      </div><div class="line">    <span class="keyword">this</span>.cb = cb</div><div class="line">    <span class="keyword">this</span>.expression = expOrFn.toString()</div><div class="line">    <span class="comment">// parse expression for getter</span></div><div class="line">    <span class="comment">// 把需要观察的属性值表达式解析成一个可执行的函数</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.getter = expOrFn</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 这里会调用pushTarget和一次getter</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建一个<code>Watcher</code>对象需要的构造参数中包括</p>
<ul>
<li><code>expOrFn</code>，表示需要监听的属性名</li>
<li><code>cb</code>，对应属性名的值发生变化时的回调，用于处理相应的业务逻辑（比如更新视图）</li>
</ul>
<p>###Dep</p>
<p><code>Dep</code>用来连接<code>Observer</code>和<code>Watcher</code>，并充当事件变化的发布者：通过<code>Observer</code>提供的set和get，在get中收集<code>Watcher</code>，在set中通知<code>Watcher</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span> () &#123;</div><div class="line">    <span class="keyword">this</span>.id = uid++</div><div class="line">    <span class="keyword">this</span>.subs = []</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123;</div><div class="line">    <span class="comment">// stabilize the subscriber list first</span></div><div class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面只是复制粘贴了相关的实现源码，那么，这三个类是如何关联起来的呢？</p>
<h3 id="Observer与Dep的关联"><a href="#Observer与Dep的关联" class="headerlink" title="Observer与Dep的关联"></a>Observer与Dep的关联</h3><p>首先，在<code>Observer</code>的walk方法中，对数据对象的每个属性进行劫持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">walk (obj: <span class="built_in">Object</span>) &#123;</div><div class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    	defineReactive(obj, keys[i], obj[keys[i]])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看见实际上是<code>defineReactive</code>在工作，这个函数在其他的源文件中也出现过很多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  obj: Object,</span></span></div><div class="line"><span class="function"><span class="params">  key: string,</span></span></div><div class="line"><span class="function"><span class="params">  val: any,</span></span></div><div class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></div><div class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  	</div><div class="line">  <span class="comment">// 递归劫持setter和getter</span></div><div class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = val</div><div class="line">      <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">        <span class="comment">// 收集依赖</span></div><div class="line">        dep.depend()</div><div class="line">        <span class="keyword">if</span> (childOb) &#123;</div><div class="line">          childOb.dep.depend()</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = val</div><div class="line">      <span class="comment">// 新旧值相同不触发更新的原因</span></div><div class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      val = newVal</div><div class="line">      childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">      <span class="comment">// 通知订阅者</span></div><div class="line">      dep.notify()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里通过<code>defineReactive</code>与<code>set</code>和<code>get</code>形成闭包，为数据的每个属性（包括子属性）都维护了一个<code>Dep</code>对象，可以看见：</p>
<ul>
<li>在<code>get</code>中通过<code>dep.depend()</code>添加订阅者</li>
<li>在<code>set</code>中通过<code>dep.notify()</code>通知订阅者</li>
</ul>
<p>其中还有一些检测属性描述符<code>configurable</code>、已设置的<code>setter</code>和<code>getter</code>等代码，这里先省略了</p>
<h3 id="Watcher与Dep的关联"><a href="#Watcher与Dep的关联" class="headerlink" title="Watcher与Dep的关联"></a>Watcher与Dep的关联</h3><p>这个就简单了，Dep作为发布者，Watcher作为订阅者，直接通过其接口关联即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dep.addSub</span></div><div class="line">addSub (sub: Watcher) &#123;</div><div class="line">  	<span class="keyword">this</span>.subs.push(sub)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watcher.addDep</span></div><div class="line">addDep (dep: Dep) &#123;</div><div class="line">    <span class="keyword">const</span> id = dep.id</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</div><div class="line">      dep.addSub(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而在上面添加订阅者的时候，我们发现是通过<code>dep.depend()</code>来实现的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dep.depend</span></div><div class="line">depend () &#123;</div><div class="line">    <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">      Dep.target.addDep(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了一个静态对象<code>Dep.target</code>，来标识当前的<code>Watcher</code>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dep.js</span></div><div class="line">Dep.target = <span class="literal">null</span></div><div class="line"><span class="keyword">const</span> targetStack = []</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</div><div class="line">  Dep.target = _target</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Watcher</code>构造函数中的最后一句调用了<code>this.get()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// watcher.js</span></div><div class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watcher.get</span></div><div class="line">get()&#123;</div><div class="line">  <span class="comment">// 这里先将Dep.target关联到当前的Watcher实例对象</span></div><div class="line">  pushTarget(<span class="keyword">this</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// getter实际上就是Watcher观察的属性表达式</span></div><div class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</div><div class="line">   &#125;<span class="keyword">catch</span> (e) &#123;</div><div class="line">     <span class="comment">// ...</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面一步步分析：</p>
<ul>
<li><code>Watcher</code>的构造函数中，我们可以了解到<code>this.getter</code>实际上就是构造参数<code>expOrFn</code>的函数形式（这是在<code>/src/core/util/lang.js</code>的<code>parsePath</code>实现的），其作用就是获取数据对象对应属性表达式的值，这里相当于调用了一次<code>get</code>，</li>
<li>调用<code>get</code>，这样就可以触发<code>defineReactive</code>中该属性描述符<code>get</code>中的<code>dep.depend()</code>，</li>
<li>由于在调用<code>get</code>之前先通过<code>pushTarget(this)</code>将Dep.target关联到当前的Watcher实例对象，从而为当前属性的发布者<code>dep</code>添加订阅者。</li>
</ul>
<p>再回头看一看整个流程，我们传入了<code>data</code>数据对象</p>
<ul>
<li>首先通过<code>observe(data</code>)，实例化一个<code>Observer</code>对象，其作用是通过<code>defineReactive</code>劫持对象属性描述符</li>
<li>数据对象data的每一个属性值都有一个<code>Dep</code>实例，在属性的<code>get</code>中收集订阅者，在属性的<code>set</code>中通知订阅者</li>
<li>在需要观察的数据属性的地方，实例化<code>Watcher</code>对象，在实例化的过程中，通过<code>pushTarget(this)</code>和一次<code>this.getter.call(vm, vm)</code>，触发<code>dep.depend</code>实现依赖的收集</li>
</ul>
<p>可以看见，<code>Dep</code>对象充当联结<code>Observer</code>和<code>watcher</code>对象之间的桥梁。实际上，属性值的<code>set</code>描述符才是真正的发布者。</p>
<h3 id="单独处理的数组"><a href="#单独处理的数组" class="headerlink" title="单独处理的数组"></a>单独处理的数组</h3><p><a href="https://cn.vuejs.org/v2/guide/list.html#数组更新检测" target="_blank" rel="external">列表渲染</a>的文档中提到</p>
<blockquote>
<p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。</p>
</blockquote>
<p>在JavaScript中，数组是一种特殊的对象，通过<code>walk</code>遍历对象属性的方法，并不能实现预期的依赖收集和更新通知，那么该如何检测数组本身的变化，诸如添加元素、移除元素呢？</p>
<p>Vue的做法是新建一个数组原型并重写相关方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment</div><div class="line">augment(value, arrayMethods, arrayKeys)</div></pre></td></tr></table></figure>
<p>其中<code>arrayMethods</code>就是增强版的数组原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/observer/array.js</span></div><div class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</div><div class="line">;[</div><div class="line">  <span class="string">'push'</span>,</div><div class="line">  <span class="string">'pop'</span>,</div><div class="line">  <span class="string">'shift'</span>,</div><div class="line">  <span class="string">'unshift'</span>,</div><div class="line">  <span class="string">'splice'</span>,</div><div class="line">  <span class="string">'sort'</span>,</div><div class="line">  <span class="string">'reverse'</span></div><div class="line">]</div><div class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> original = arrayProto[method]</div><div class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 在这里通知所有的订阅者</span></div><div class="line">    ob.dep.notify()</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后修改数组数据对象的原型，使其指向增强版的数组原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">    <span class="keyword">const</span> augment = hasProto</div><div class="line">    ? protoAugment</div><div class="line">    : copyAugment</div><div class="line">    <span class="comment">// 如果是数据对象为数组，修改其原型为增强版的数组原型</span></div><div class="line">    augment(value, arrayMethods, arrayKeys)</div><div class="line">    <span class="keyword">this</span>.observeArray(value)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="keyword">this</span>.walk(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在遍历数组，然后分别为每个数组元素均实例化Observer对象即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</div><div class="line">  	observe(items[i])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过分析，现在对于Vue中的响应式系统有了一个更直观的了解~尽管仍旧忽略了不少实现细节。然后明白了其中的一些限制</p>
<ul>
<li>Vue不能检测到对象属性的添加或删除，这是因为整个<code>observer(data)</code>是在初始化的时候对属性进行劫持的，解决这个问题的办法是通过<code>Vue.set()</code>这个API，或者创建一个包含原对象属性和新属性的新对象，通过赋值的形式</li>
<li>Vue无法检测到数组的长度变化，即<code>this.arr[this.arr.length] = xxx</code>无法触发更新。除非我们使用Vue实现的增强版数组原型方法才可以。</li>
</ul>
<p>我们知道，响应式数据最大的好处就是在数据更新时自动更新视图，让开发者只需要关注数据本身。现在了解了整个响应式数据的原理，接下来就是了解Vue的视图渲染，以及数据更新时触发的视图更新。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/Vue" class="article_tag">#Vue</a>
        
        <a href="/tags/源码分析" class="article_tag">#源码分析</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据代理"><span class="toc-number">1.</span> <span class="toc-text">数据代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应式数据"><span class="toc-number">2.</span> <span class="toc-text">响应式数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">2.1.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer与Dep的关联"><span class="toc-number">2.2.</span> <span class="toc-text">Observer与Dep的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher与Dep的关联"><span class="toc-number">2.3.</span> <span class="toc-text">Watcher与Dep的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析"><span class="toc-number">2.4.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单独处理的数组"><span class="toc-number">2.5.</span> <span class="toc-text">单独处理的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>