<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">Vue源码阅读笔记之模板渲染（三）</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/12/13 20:21:6</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>这是”Vue源码阅读笔记”系列第三篇文章。在前面我们分析了Vue响应式数据系统，并了解到当数据变化时会通知变化属性的Watcher，然后更新视图。渲染模板和更新视图的逻辑均由Vue内部封装，我们只需要关注数据的逻辑即可，接下来就让我们学习Vue的模板系统。</p>
<a id="more"></a>
<p>参考：</p>
<ul>
<li><a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="external">理解Virtual DOM</a></li>
<li><a href="http://web.jobbole.com/91819/" target="_blank" rel="external">深入vue2.0底层思想–模板渲染</a></li>
</ul>
<p>我们知道Vue不仅可以运行在浏览器环境中，也可以通过SSR渲染。因此针对不同的运行环境，输出结果肯定是不一样的。我们从<code>Vue.prototype._init</code>方法中可以找到相关模板挂载方法的调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">	vm.$mount(vm.$options.el)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在不同的运行环境中，<code>Vue.prototype.$mount</code>的实现是不一样的，我们从这里入手。</p>
<h2 id="Vue-prototype-mount"><a href="#Vue-prototype-mount" class="headerlink" title="Vue.prototype.$mount"></a>Vue.prototype.$mount</h2><p>首先我们找到浏览器环境下<code>$mount</code>的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/platforms/entry-runtime-with-compiler.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  el = el &amp;&amp; query(el)</div><div class="line"></div><div class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">  <span class="comment">// resolve template/el and convert to render function</span></div><div class="line">  <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">    <span class="keyword">let</span> template = options.template</div><div class="line">    </div><div class="line">    <span class="comment">// 这里对template及el参数进行重载，用于获取模板内容</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    </div><div class="line">    <span class="comment">// 然后对template进行编译</span></div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">        shouldDecodeNewlines,</div><div class="line">        shouldDecodeNewlinesForHref,</div><div class="line">        delimiters: options.delimiters,</div><div class="line">        comments: options.comments</div><div class="line">      &#125;, <span class="keyword">this</span>)</div><div class="line">      options.render = render</div><div class="line">      options.staticRenderFns = staticRenderFns</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 调用公共的mount方法，</span></div><div class="line">  <span class="comment">// 内部调用的是 /src/core/instance/lifecycle.js中的 mountComponent 方法</span></div><div class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先不考虑<code>options.render</code>的情况，<code>$mount</code>中做了三件事：</p>
<ul>
<li>找到对应的模板</li>
<li>将模板进行解析，并将解析结果<code>render</code>和<code>staticRenderFns</code>挂载到<code>options</code>上面</li>
<li>调用<code>mountComponent</code>，并执行相关渲染函数<code>render</code></li>
</ul>
<p>从<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="external">文档：渲染函数 &amp; JSX</a>可以得知，Vue允许我们通过<code>render</code>配置项替代<code>template</code>选项，其格式为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(createElement: <span class="function"><span class="params">()</span> =&gt;</span> VNode) =&gt; VNode</div></pre></td></tr></table></figure>
<p>通过<code>createElement</code>生成<code>VNode</code>，通过<code>VNode</code>构建<strong>虚拟DOM树</strong>。</p>
<p>如果配置参数中存在<code>render</code>则会跳过第二步，那么先让我们来看看对应的render函数的作用，然后再去分析如果将<code>template</code>转换成<code>render</code>函数的。</p>
<h2 id="Render渲染函数"><a href="#Render渲染函数" class="headerlink" title="Render渲染函数"></a>Render渲染函数</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>首先来看看<code>mountComponent</code>方法的工作内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/lifecycle.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  vm: Component,</span></span></div><div class="line"><span class="function"><span class="params">  el: ?Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  vm.$el = el</div><div class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</div><div class="line">    vm.$options.render = createEmptyVNode</div><div class="line">  &#125;</div><div class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">let</span> updateComponent</div><div class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> name = vm._name</div><div class="line">      <span class="keyword">const</span> id = vm._uid</div><div class="line">      <span class="comment">// 这里移除了性能测量相关的一些代码</span></div><div class="line">      <span class="comment">// 可以看见，_render()函数返回的就是VNode节点</span></div><div class="line">      <span class="keyword">const</span> vnode = vm._render()</div><div class="line">      </div><div class="line">      vm._update(vnode, hydrating)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 实例Watcher对象，绑定响应式数据，这在下面的模板更新会提到</span></div><div class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</div><div class="line">  hydrating = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</div><div class="line">    vm._isMounted = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'mounted'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> vm</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看见的是，实例化Watcher对象是在这里进行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</div></pre></td></tr></table></figure>
<p>在前一篇分析响应式原理中了解到，在<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/watcher.js" target="_blank" rel="external">Watcher构造函数</a>中，如果<code>expOrFn</code>是函数(这里就是<code>updateComponent</code>函数)，则会将其赋值给<code>watcher.getter</code>，然后调用一次<code>getter</code>实现依赖收集。</p>
<p>了解了执行流程，我们知道了在<code>$mount</code>函数中会调用<code>vm._render</code>方法，在前面分析<a href="/article/Vue源码阅读笔记之项目结构和Vue对象（一）">Vue原型对象</a>的时候了解到，</p>
<ul>
<li><code>vm._render()</code>即<code>Vue.prototype._render</code>在<code>lifecycleMixin</code>实现</li>
<li><code>vm._update</code>在<code>renderMixin</code>中实现，这里面主要实现diff，我们暂时放在一边</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/render.js</span></div><div class="line"></div><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  	<span class="comment">// 没错，终于找到了配置参数上面的render函数，也就是template编译后生成的render函数</span></div><div class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</div><div class="line">    <span class="comment">// 这里移除了$slots相关处理代码</span></div><div class="line">    vm.$vnode = _parentVnode</div><div class="line">    <span class="comment">// 这里移除了渲染错误相关处理代码</span></div><div class="line">  	</div><div class="line">    <span class="keyword">let</span> vnode</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// render函数在这里被调用</span></div><div class="line">      <span class="comment">// 其中vm._renderProxy在 /src/core/instance/proxy.js中定义</span></div><div class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      handleError(e, vm, <span class="string">`render`</span>)</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    vnode.parent = _parentVnode</div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>最后，我们终于找到了调用<code>render</code>的地方</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</div></pre></td></tr></table></figure>
<p>不论是通过配置参数传入的<code>render</code>函数直接，还是通过<code>template</code>编译后得到的render函数，最后都会在这里被调用，并返回对应的VNode，那么render函数和VNode到底长啥样呢？</p>
<h3 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h3><p>Vue2引入了<strong>虚拟DOM</strong>的概念。</p>
<blockquote>
<p>高效的更新所有这些节点会是比较困难的，不过所幸你不必再手动完成这个工作了。你只需要告诉 Vue 你希望页面上的 HTML 是什么</p>
</blockquote>
<p>上面提到的“这些节点”指的是页面中的真实DOM，由于操作真实DOM的性能代价比较昂贵，</p>
<ul>
<li>构建一个真实的DOM对象，其大部分属性是我们不需要的</li>
<li>维护许多真实DOM对象的更新，需要占据大量的内存</li>
</ul>
<p>而虚拟DOM可以看做是简化版的DOM树，虚拟DOM树上的虚拟节点即<strong>VNode</strong>，他们通过JavaScript对象构建：</p>
<blockquote>
<p>VNode它更准确的名字可能是 <code>createNodeDescription</code>，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点</p>
</blockquote>
<p>执行JavaScript代码的效率是远远高于操作真实DOM的效率的。关于虚拟DOM的深入理解及实现，可以参考这篇文章：<a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="external">理解 Virtual DOM </a>。</p>
<p>这里我们需要知道的是：<code>render</code>函数返回的，就是一个虚拟的DOM树</p>
<h3 id="render函数的形式"><a href="#render函数的形式" class="headerlink" title="render函数的形式"></a>render函数的形式</h3><p>为了方便分析，我们来写个最简单的模板测试下，然后跟着断点前进</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in arr"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  	<span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></div><div class="line"><span class="javascript">        el: <span class="string">"#app"</span>,</span></div><div class="line"><span class="undefined">        data: &#123;</span></div><div class="line"><span class="javascript">            msg: <span class="string">"Hello Vue"</span>,</span></div><div class="line"><span class="undefined">          	arr: [1,2,3]</span></div><div class="line"><span class="undefined">        &#125;,</span></div><div class="line"><span class="undefined">    &#125;)</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>先打印<code>render</code>函数看看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">return</span> _c(<span class="string">"div"</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">"app"</span> &#125; &#125;, [</div><div class="line">      _c(<span class="string">"h1"</span>, [_v(_s(msg))]),</div><div class="line">      _v(<span class="string">" "</span>),</div><div class="line">      _c(</div><div class="line">        <span class="string">"ul"</span>,</div><div class="line">        _l(arr, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> _c(<span class="string">"li"</span>, [_v(_s(item))]);</div><div class="line">        &#125;)</div><div class="line">      )</div><div class="line">    ]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果把上面的模板通过配置参数的render函数实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">	<span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></div><div class="line"><span class="javascript">        el: <span class="string">"#app"</span>,</span></div><div class="line"><span class="undefined">        data: &#123;</span></div><div class="line"><span class="javascript">            msg: <span class="string">"Hello World"</span>,</span></div><div class="line"><span class="undefined">            arr: [1,2,3]</span></div><div class="line"><span class="undefined">        &#125;,</span></div><div class="line"><span class="javascript">        render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">return</span> createElement(<span class="string">"div"</span>, &#123;</span></div><div class="line"><span class="undefined">                attrs: &#123;</span></div><div class="line"><span class="javascript">                    id: <span class="string">"#app"</span></span></div><div class="line"><span class="undefined">                &#125;</span></div><div class="line"><span class="undefined">            &#125;, [</span></div><div class="line"><span class="javascript">                createElement(<span class="string">"h1"</span>, <span class="keyword">this</span>.msg),</span></div><div class="line"><span class="javascript">                createElement(<span class="string">"ul"</span>, [</span></div><div class="line"><span class="javascript">                    <span class="keyword">this</span>.arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span></div><div class="line"><span class="javascript">                        <span class="keyword">return</span> createElement(<span class="string">'li'</span>, item)</span></div><div class="line"><span class="undefined">                    &#125;)</span></div><div class="line"><span class="undefined">                ])</span></div><div class="line"><span class="undefined">            ])</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">    &#125;)</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以发现，我们自定义的render函数，与通过template编译获得的render函数惊人地相似。</p>
<p>那么，也就不难理解<code>_c</code>、<code>_v</code>、<code>_l</code>这些字母函数的作用了：生成对应的VNode和虚拟DOM树结构。</p>
<p>回到上面那个匿名的render函数，通过with绑定当前作用域到<code>vm._renderProxy</code>(可以理解为vm自身)。也就是说，接下来我们的目标就是去寻找的来源及作用。</p>
<h3 id="render函数的辅助函数"><a href="#render函数的辅助函数" class="headerlink" title="render函数的辅助函数"></a>render函数的辅助函数</h3><p>同样是在前面分析Vue构造函数和对象的时候了解到，相关的方法是通过<code>renderMixin</code>函数中调用<code>installRenderHelpers(Vue.prototype)</code>注册的。（PS：侧面说明先熟悉整体结构的必要性，比到处乱翻源码要轻松得多啊~）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/render-helpers.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installRenderHelpers</span> (<span class="params">target: any</span>) </span>&#123;</div><div class="line">  target._o = markOnce</div><div class="line">  target._n = toNumber</div><div class="line">  target._s = toString</div><div class="line">  target._l = renderList</div><div class="line">  target._t = renderSlot</div><div class="line">  target._q = looseEqual</div><div class="line">  target._i = looseIndexOf</div><div class="line">  target._m = renderStatic</div><div class="line">  target._f = resolveFilter</div><div class="line">  target._k = checkKeyCodes</div><div class="line">  target._b = bindObjectProps</div><div class="line">  target._v = createTextVNode</div><div class="line">  target._e = createEmptyVNode</div><div class="line">  target._u = resolveScopedSlots</div><div class="line">  target._g = bindObjectListeners</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>慢着！上面好像漏掉了最重要的<code>vm._c</code>函数，这是在<code>_init</code>方法中通过<code>initRender</code>方法注册的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>我们先不用管具体的实现细节（尤其是<code>createElement</code>），只需要知道他们是用来方便生成对应的DOM结构即可，这些方法最终会组成render函数然后被执行。</p>
<p>OK，现在我们了解了<code>$mount</code>方法的执行流程，也清楚了<code>render</code>函数的大致样子和作用。接下来我们看看，如果通过配置参数传入<code>template</code>，Vue内部是如何将其编译成render函数的。</p>
<h2 id="生成Render函数"><a href="#生成Render函数" class="headerlink" title="生成Render函数"></a>生成Render函数</h2><h3 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h3><p>回到<code>Vue.prototype.$mount</code>的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	&#125;, <span class="keyword">this</span>)</div><div class="line">options.render = render</div></pre></td></tr></table></figure>
<p>逐步找到<code>compileToFunctions</code>的出处，由于代码比较多，为了更清晰地了解整个流程，简化了很多代码，只保留了参数和返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/platforms/web/compiler/index.js</span></div><div class="line"><span class="keyword">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</div><div class="line"></div><div class="line"><span class="comment">// /src/compiler/index.js</span></div><div class="line"><span class="comment">// Vue允许自定义其他的编译函数，这里声明编译函数的接口，并提供了一个基本的编译函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  template: string,</span></span></div><div class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</div><div class="line">  <span class="comment">// 将模板解析成AST树</span></div><div class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</div><div class="line">  <span class="comment">// 优化AST树</span></div><div class="line">  optimize(ast, options)</div><div class="line">  <span class="comment">// 编译模板数据</span></div><div class="line">  <span class="keyword">const</span> code = generate(ast, options)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// /src/compiler/create-compiler.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompilerCreator</span> (<span class="params">baseCompile: Function</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompiler</span> (<span class="params">baseOptions: CompilerOptions</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">// ... </span></div><div class="line">      <span class="comment">// 编译函数的返回结果，就是上面的 &#123; ast, render, staticRenderFns &#125;</span></div><div class="line">      <span class="keyword">const</span> compiled = baseCompile(template, finalOptions)</div><div class="line">      <span class="keyword">return</span> compiled</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      compile,</div><div class="line">      <span class="comment">// 传入compile函数，获得compileToFunctions函数</span></div><div class="line">      compileToFunctions: createCompileToFunctionFn(compile)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /src/compiler/to-function.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompileToFunctionFn</span> (<span class="params">compile: Function</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    template: string,</span></span></div><div class="line"><span class="function"><span class="params">    options?: CompilerOptions,</span></span></div><div class="line"><span class="function"><span class="params">    vm?: Component</span></span></div><div class="line"><span class="function"><span class="params">    </span>): <span class="title">CompiledFunctionResult</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">const</span> compiled = compile(template, options)</div><div class="line">    <span class="comment">// 这里即$mount方法中编译模板得到的结果</span></div><div class="line">    res.render = createFunction(compiled.render, fnGenErrors)</div><div class="line">    res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> createFunction(code, fnGenErrors)</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> (cache[key] = res)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的使用了大量的闭包，不要被绕晕了，简单梳理一下流程</p>
<ul>
<li>编译模板需要实现一个<code>compile</code>编译函数的接口，Vue内置了一个<code>baseCompile</code>函数</li>
<li><code>createCompilerCreator</code>接收<code>baseCompile</code>函数，并返回<code>createCompiler</code>函数</li>
<li><code>createCompileToFunctionFn</code>接收一个compile编译函数，并返回<code>compileToFunctions</code></li>
</ul>
<ul>
<li><code>createCompiler</code>函数中调用<code>baseCompile</code>构建compile函数，并将compile函数传递给<code>createCompileToFunctionFn</code>，返回<code>compileToFunctions</code>函数</li>
<li><code>compileToFunctions</code>函数接收一个<code>template</code>模板和配置参数，最后返回render函数</li>
</ul>
<p>好吧，这个确实有点绕。</p>
<h3 id="baseCompile"><a href="#baseCompile" class="headerlink" title="baseCompile"></a>baseCompile</h3><p>事实上经过简单的分析，我们就可以发现，真正的解析工作是在<code>baseCompile</code>这个函数中进行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  template: string,</span></span></div><div class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</div><div class="line">  optimize(ast, options)</div><div class="line">  <span class="keyword">const</span> code = generate(ast, options)</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现这里执行的三个函数:<code>parse</code>、<code>optimize</code>和<code>generate</code>，找到对应的定义文件，先大致了解他们的作用。</p>
<p><strong>parse</strong></p>
<p>这个函数主要用来将 template字符串解析成 AST</p>
<p>首先要理解的是<strong>AST</strong>，下面摘自<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9" target="_blank" rel="external">维基百科</a>:</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="external">计算机科学</a>中，<strong>抽象语法树</strong>（<em>abstract syntax tree</em>或者缩写为<em>AST</em>），或者<strong>语法树</strong>（<em>syntax tree</em>），是<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" target="_blank" rel="external">源代码</a>的抽象<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%AD%A6" target="_blank" rel="external">语法</a>结构的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA" target="_blank" rel="external">树</a>)状表现形式，这里特指<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" target="_blank" rel="external">编程语言</a>的<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81" target="_blank" rel="external">源代码</a>。树上的每个节点都表示源代码中的一种结构</p>
</blockquote>
<p>在<code>/flow/compiler.js</code>中可以找到AST的相关类型声明，包含<code>ASTElement</code>、<code>ASTExpression</code>和<code>ASTText</code>三种类型。</p>
<p>也就是说，parse的主要功能就是解析template，包括模板标签、指令和属性等，并返回一个AST对象。其内部实现比较复杂，大致是通过正则匹配进行的。</p>
<p>之前写过的一个简单的<a href="/article/JS模板引擎（初级篇）">JS模板引擎</a>，至于Vue这里具体的解析实现，暂时没有深入。可以先看看返回的ast结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">type</span>: <span class="number">1</span>, <span class="attr">tag</span>: <span class="string">"div"</span>, <span class="attr">attrsList</span>: <span class="built_in">Array</span>(<span class="number">1</span>), <span class="attr">attrsMap</span>: &#123;…&#125;, <span class="attr">parent</span>: <span class="literal">undefined</span>, …&#125;</div></pre></td></tr></table></figure>
<p><strong>optimize</strong></p>
<p>这个函数主要用来标记ast的静态节点，优化虚拟DOM树，被标记为 static 的节点，会在更新时被忽略，为后面 patch 过程中对比新旧 VNode 树形结构做优化</p>
<p><strong>generate</strong></p>
<p>这个函数根据 ast 拼接生成 render 函数的字符串，在其内部对ast结构进行解析，使用在前面提到的render辅助函数，并拼接成对应的虚拟DOM树。</p>
<p>最后生成的render函数，就是我们控制台所输出的那种形式~</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>render函数的生成是一个比较复杂的地方，这里我直接避开了其内部的具体实现，只是分析了从template到render函数的转换流程，目的是为了避免陷入模板解析的泥潭中。实际上这并不影响我们后续的分析（嗯~假装自己说的很有道理）。</p>
<h2 id="模板更新"><a href="#模板更新" class="headerlink" title="模板更新"></a>模板更新</h2><p>在<code>mountComponent</code>函数中，我们找到了下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> updateComponent</div><div class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> name = vm._name</div><div class="line">      <span class="keyword">const</span> id = vm._uid</div><div class="line">      <span class="keyword">const</span> vnode = vm._render()</div><div class="line">      vm._update(vnode, hydrating)</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// 实例Watcher对象，绑定响应式数据</span></div><div class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</div></pre></td></tr></table></figure>
<p>我们已经知道，</p>
<ul>
<li>在进行依赖收集时，会对调用一次get，这里即<code>updateComponent</code>函数；</li>
<li>在数据发生变化时，Dep会通知Watcher订阅者的<code>update</code>方法，实际上又会调用<code>updateComponent</code>；</li>
<li>在<code>updateComponent</code>方法内部，调用了<code>vm._render</code>和<code>vm._update</code>方法</li>
</ul>
<p>在上一节我们已经分析了<code>render</code>函数，现在让我们来看看<code>update</code>的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/lifecycle.js</span></div><div class="line"></div><div class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> prevEl = vm.$el</div><div class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</div><div class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</div><div class="line">    activeInstance = vm</div><div class="line">    vm._vnode = vnode</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">      <span class="comment">// 第一次初始化</span></div><div class="line">      vm.$el = vm.__patch__(</div><div class="line">        vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</div><div class="line">        vm.$options._parentElm,</div><div class="line">        vm.$options._refElm</div><div class="line">      )</div><div class="line">      vm.$options._parentElm = vm.$options._refElm = <span class="literal">null</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 数据变化，diff新旧虚拟DOM树，修改变化的VNode</span></div><div class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>vm.__patch__</code>在<code>/src/instance/vdom/patch.js</code>中定义。其作用就是实现新旧 VNode 对比的 diff 函数，然后将对应的VNode转换成真实DOM，然后<strong>添加到页面上</strong>。如果想要深入diff算法，可以参考这篇文章：<a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="external">解析vue2.0的diff算法</a>。</p>
<p>换句话说，视图的更新是在<code>vm._update</code>中，通过<code>vm.__patch__</code>实现的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个模板渲染和更新的过程似乎已经逐渐清晰了，简单整理一下：</p>
<ul>
<li>在<code>initData</code>中，通过Observer修改data的属性访问描述符，将其转换为可监控的值</li>
</ul>
<ul>
<li>在 <code>$mount</code> 中，通过 <code>updateComponent</code>实例化了Watcher对象，并在<code>updateComponent</code>这个getter中对 <code>render</code> 和<code>update</code>求值，<ul>
<li>第一次执行<code>render</code> 时会编译模板，并生成对应的render函数，render函数会返回虚拟DOM树；</li>
<li>第一次执行<code>update</code>时，会将VNode转换为真实DOM，然后渲染页面。</li>
</ul>
</li>
<li>当变量改变时，Dep通过调用Watcher对象的update方法，再次执行<code>updateComponent</code> <ul>
<li>后续执行<code>render</code>时，会从缓存中提取已编译的render函数，</li>
<li>后续执行<code>update</code>时，会通过diff算法计算需要更新的VNode，然后实现 <code>re-render</code>，实现视图的更新。</li>
</ul>
</li>
</ul>
<p>这篇文章的篇幅不短，实际上只研究了两个地方:</p>
<ul>
<li>template编译成render函数的过程</li>
<li>数据变化自动更新视图的实现</li>
</ul>
<p>其中还有很多细节，比如模板转换成AST、diff算法等，都没有进一步深入，这些地方还需要继续学习才行。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/Vue" class="article_tag">#Vue</a>
        
        <a href="/tags/源码分析" class="article_tag">#源码分析</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-prototype-mount"><span class="toc-number">1.</span> <span class="toc-text">Vue.prototype.$mount</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Render渲染函数"><span class="toc-number">2.</span> <span class="toc-text">Render渲染函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行流程"><span class="toc-number">2.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VNode"><span class="toc-number">2.2.</span> <span class="toc-text">VNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render函数的形式"><span class="toc-number">2.3.</span> <span class="toc-text">render函数的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render函数的辅助函数"><span class="toc-number">2.4.</span> <span class="toc-text">render函数的辅助函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成Render函数"><span class="toc-number">3.</span> <span class="toc-text">生成Render函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行流程-1"><span class="toc-number">3.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#baseCompile"><span class="toc-number">3.2.</span> <span class="toc-text">baseCompile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">3.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板更新"><span class="toc-number">4.</span> <span class="toc-text">模板更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>