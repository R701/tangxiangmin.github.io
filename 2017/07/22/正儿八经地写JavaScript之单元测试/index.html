<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
            <a class="nav_item" href="/test">Test</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">正儿八经地写JavaScript之单元测试</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/7/22 22:45:59</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>前段时间阅读《Android编程权威指南》，第21章专门介绍了Android中的单元测试，当时照猫画虎进行了一点练习，感觉在项目中引入单元测试确实是一件事半功倍的事情。于是开始着手查询JavaScript单元测试，才发现原来已经有这么多工具了。下面是对单元测试与<code>Mocha</code>使用心得的一些整理。</p>
<a id="more"></a>
<p>在谷歌下搜索<code>javascript unit test</code>，推荐链接展示了一堆<code>mocha</code>的相关搜索，发现原来是<code>TJ</code>大神写的，作为一个脑残粉，于是就选择了<code>mocha</code>。</p>
<p>参考：</p>
<ul>
<li><p><a href="https://mochajs.org/" target="_blank" rel="external">官方文档</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/tzyy/p/5729602.html" target="_blank" rel="external">javascript单元测试框架mochajs详解</a></p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">测试框架 Mocha 实例教程-阮一峰</a></p>
</li>
<li><p><a href="http://taobaofed.org/blog/2015/12/10/nodejs-unit-tests/" target="_blank" rel="external">Node.js 单元测试：我要写测试</a></p>
</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>开发是一个增量的过程，拿最近的项目来说：</p>
<ul>
<li>前期需要按照指定的规则（类似于一个模板引擎）在客户端解析用户上传的txt文本，提取作者，时间，概述等基本内容；</li>
<li>需求更新，要求在原来的解析规则上适当放开限制，提高代码的容错率</li>
<li>需求更新，运行用户上传docx文档，解析图片内容并自动上传到服务器，替换为对应的URL</li>
</ul>
<p>总体来说这个需求是围绕着文本解析进行的。在最初开发的时候，根本不知道后面的需求迭代；而后续开发是在前面的功能基础上进行的，尤其是第二条，简单来讲就是增加可匹配的标签，但是必须提防的是增加的标签不会影响前面已经实现的功能~总之越往开发后期，代码改的越心惊胆颤。</p>
<p>要是早点学习了单元测试该多好！单元测试就是为了<strong>验证代码的功能是否会如预期般生效</strong>。</p>
<p>我的理解是：我们会在开发过程中手动去检测某个函数是否会返回正确的结果，某个分支是否会在指定条件下进入等，单元测试就是用来测试我们写的功能代码，更重要的是，测试代码是可以<strong>重复执行的</strong>，也就是说，我们可以在后续开发的过程中折回来测试先前的功能，需要的成本仅仅只是执行一个命令而已。</p>
<p>那么，测试框架又是什么呢？</p>
<blockquote>
<p>测试框架的职责即提供一套 API 帮助开发者更方便的测试代码</p>
</blockquote>
<p>简单来讲，测试框架可以更方便的帮我们保管（组织）测试代码，展示测试结果及测试覆盖率等；具体来讲，测试框架可以帮我们执行测试逻辑，包括异步测试，测试过程钩子函数，断言库等。</p>
<p>选择mocha的原因主要是：<strong>攻略太多了啊喂~</strong></p>
<h2 id="mocha使用"><a href="#mocha使用" class="headerlink" title="mocha使用"></a>mocha使用</h2><p>关于mocha的使用，官网上已经介绍的比较详细了，网上也能找到大量的教程。这里只是简单整理一下。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>只需要进行下面三步即可：</p>
<ul>
<li>全局安装mocha，<code>mocha -h</code>可查看帮助命令</li>
<li>在项目目录下新增一个<code>test</code>文件夹，用于存放测试文件，一般命名为<code>XX.test.js</code>这样</li>
<li>然后在与<code>test</code>同级的目录使用<code>mocha</code>命令，会自动执行<code>test</code>目录下的所有js文件（所以测试目录下就不要放其他无关的文件了）</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="describe和it"><a href="#describe和it" class="headerlink" title="describe和it"></a>describe<strong>和</strong>it</h4><ul>
<li><code>describe</code>方法用来描述和执行一组测试，第一个参数会输出到控制台，作为这组测试的标识符</li>
<li><code>it</code>方法用来描述某个测试用例，同样会在控制台输出，如果测试用例通过，则会在其前面打勾</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">"assert"</span>);</div><div class="line"></div><div class="line">describe(<span class="string">"demo"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  	it(<span class="string">"100% success"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      	assert.equal(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">  	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>相关的文字描述可以用来组织层次化的测试用例，比如针对某个的对象的某些方法，为每个方法进行数个测试案例，则代码层次可以为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">"demo"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	describe(<span class="string">"foo"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	  	it(<span class="string">""</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	  		<span class="comment">// todo some assert</span></div><div class="line">	  	&#125;)</div><div class="line">	  	it(<span class="string">"xxx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	  		<span class="comment">// some assert</span></div><div class="line">	  	&#125;)</div><div class="line">	&#125;)</div><div class="line">	</div><div class="line">	describe(<span class="string">"bar"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	  	it(<span class="string">"xxx"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	  		<span class="comment">// some assert</span></div><div class="line">	  	&#125;)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">  	it(<span class="string">"100% success"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      	assert.equal(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">  	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>测试代码主要是为开发人员服务，因此语义化的代码尤其重要，为了更加直观的组织测试代码，mocha还额外提供了一个<code>context</code>方法，实际上他只是<code>describe</code>方法的别名而已，可以灵活使用。</p>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>在测试过程中，mocha提供了4个钩子函数</p>
<ul>
<li><code>before</code>，在当前<code>describe</code>块的所有测试用例之前调用，调用一次</li>
<li><code>after</code>，在当前<code>describe</code>块的所有测试用例之后调用，调用一次</li>
<li><code>beforeEach</code>，在当前<code>describe</code>块的每个测试用例调用之前都会调用，调用N次</li>
<li><code>afterEach</code>，在当前<code>describe</code>块的每个测试用例调用之后都会调用，调用N次</li>
</ul>
<p>下面的代码简单测试一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">"hooks"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">0</span>;</div><div class="line">  	<span class="comment">// 其余方法省略~</span></div><div class="line">	beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(++a);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  	it(<span class="string">"case 1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  		assert.equal(<span class="number">1</span>, <span class="number">1</span>)</div><div class="line">  	&#125;)</div><div class="line">  	it(<span class="string">"case 2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  		assert.equal(<span class="number">10</span>, <span class="number">10</span>)</div><div class="line">  	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>钩子函数在某些时刻非常有用，比如为了验证数据库模型的<code>insert</code>方法，需要向数据库插入一条记录，在测试执行完毕，需要将对应的记录移除（测试数据不应当保留），对应的逻辑放在钩子函数里面会非常合适。</p>
<p>需要注意的是，如果不存在<code>it</code>函数，那么也不会执行钩子函数哦~</p>
<h4 id="done"><a href="#done" class="headerlink" title="done"></a>done</h4><p>JS中的异步代码是非常常见的，比如网络请求，数据库操作，定时器等，用mocha来测试异步代码也十分简单：使用，并在异步结束执行之后调用done即可完成测试用例的执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">"demo"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">	beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  			a = <span class="number">10</span>;</div><div class="line">  			done();</div><div class="line">  		&#125;, <span class="number">1000</span>)</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  	it(<span class="string">"asynchronous demo"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  		assert.equal(a, <span class="number">10</span>)</div><div class="line">  	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>文档上的done方法讲解的并不是很容易理解，这里参考</p>
<ul>
<li><a href="http://cnodejs.org/topic/535e03d614b825ea72005067" target="_blank" rel="external">mocha异步之done</a></li>
<li><a href="https://lostechies.com/derickbailey/2012/08/17/asynchronous-unit-tests-with-mocha-promises-and-winjs/" target="_blank" rel="external">Asynchronous Unit Tests With Mocha, Promises, And WinJS</a></li>
</ul>
<p>如果在<code>describe</code>,<code>it</code>及钩子函数的回调函数中传入了<code>done</code>参数，则必须等待该<code>done</code>完成调用之后才会执行后面的测试案例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">"done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</div><div class="line">	context(<span class="string">"has done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			done();</div><div class="line">		&#125;, <span class="number">200</span>);</div><div class="line"></div><div class="line">		it(<span class="string">"done test1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">"it里的输出1"</span>);</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		it(<span class="string">"done test2"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">"it里的输出2"</span>);</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"it外的输出"</span>);</div><div class="line">	&#125;)</div><div class="line">	</div><div class="line">	context(<span class="string">"no done"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"no done()"</span>);</div><div class="line">	&#125;);</div><div class="line"> 	<span class="comment">// 执行结果依次为 it外的输出-&gt;no done()-&gt;it里的输出1-&gt;it里的输出2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可见done会阻塞它所位于块内的后面的<code>it</code>方法，我们还可以写一个通用的异步测试的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseDescribe</span>(<span class="params">describeName, task, assertFunc</span>)</span>&#123;</div><div class="line">    describe(describeName, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> globalVal = &#123;&#125;;</div><div class="line">        beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">            task(globalVal, done);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (assertFunc <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">            assertFunc.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</div><div class="line">                func(globalVal);</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            assertFunc(globalVal);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面是使用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">promiseDescribe(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">globalVal, done</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		globalVal.a = <span class="number">10</span>;</div><div class="line">		done();</div><div class="line">	&#125;)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">globalVal</span>)</span>&#123;</div><div class="line">	it(<span class="string">"should"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		assert.equal(globalVal.a, <span class="number">10</span>)</div><div class="line"></div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于文档还没有看全，之前异步代码测试我都是使用这个简陋的方法进行的。</p>
<h4 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h4><p>单元测试可以在边开发边进行测试，最好的方式的完成一个功能就编写对应的测试用例，虽然会耽搁一些时间，但是与之后返回进行手动测试相比，这一切都是值得的，此外在回头写文档的时候也可以直接参照测试用例进行。但是问题来了，在开发的时候我们只希望执行某一些测试用例而非全部测试，mocha为我们提供了相关的描述符</p>
<ul>
<li><code>it.only()</code>，只执行带有<code>only</code>修饰的测试用例，如果同时存在多个带only的测试用例，则他们都会被执行（only貌似就有点名不副实了），如果不存在only修饰，则会执行所有的测试用例，所以在开发的时候only方法非常有用（可以立即测试我们刚写的接口）。</li>
<li><code>it.skip()</code>，在某些时候测试用例需要进行调整或者跳过，则可以使用skip修饰，此时在控制台对应的测试用例会显示<code>pending</code>；对于作废的测试用例，官方的建议是skip而不是直接删除掉</li>
</ul>
<p>需要注意的是，不仅可以在某个测试用例上使用描述符，也可以为某个用例集合<code>describe</code>或<code>context</code>使用，在测试用例很多的情况下就会很有用哦~</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>前面提到，单元测试主要是为了验证程序的功能是否正常，那么，功能的正常与否是如何判断的呢？大多数时候，单元测试都是针对接口和库函数进行的，而对于接口和函数的评定标准无非是传入对应的参数，是否返回预期的结果（正确的结果由我们手动给定）。因此，在单元测试中使用断言是在正常不过的了。</p>
<p>断言即我们相信程序在某种条件下必定会输出的某个确定的结果。断言库提供了方便的api来判断程序是否输出了指定的结果，上面代码中的<code>assert</code>就是断言库。在官方文档中推荐了几种断言库</p>
<ul>
<li><code>assert</code>，node内置断言库，功能比较少</li>
<li><code>should.js</code>，听名字貌似很直观的样子</li>
<li><code>chai</code>，上面的<code>assert</code>使用的就是<code>chai</code>，不过我也是刚接触，所以不是很熟悉，这里是<a href="http://chaijs.com/api/" target="_blank" rel="external">文档</a></li>
</ul>
<p>需要注意的是，如果书写合适的断言是单元测试中一个比较难的地方，下面提到测试用例的时候会再次说明。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>为了练习单元测试，我尝试着写了一个<a href="https://github.com/tangxiangmin/mysql-xModel" target="_blank" rel="external">mysqljs模型类</a>，然后为这个模型类编写测试用例。测试用例实际上就是单独调用某个方法，并测试其输出结果的一组逻辑代码。</p>
<p>在测试的过程中，发现了不少问题。下面这几个问题是我对自己的提问，到目前为止，并没有合适的解决答案~</p>
<h3 id="如何组织测试用例"><a href="#如何组织测试用例" class="headerlink" title="如何组织测试用例"></a>如何组织测试用例</h3><p>前面也提到了，测试代码主要是面向开发人员的，因此为了高效率的开发，如何组织测试用例就显得尤为重要。</p>
<p>mocha可以在<code>describe</code>和<code>context</code>中进行嵌套，这样就可以在控制台输出树状的测试结果，非常直观。此外<code>it</code>描述语句要尽可能清晰的描述该测试用例，也就是“需要测试的单元在给定的条件和参数下会发生什么事情”。</p>
<p>此外还可以将测试用例按模块和功能以单文件的形式进行分类整理（而不是将所有的测试代码都放在同一个文件中），这点可以参考<code>jQuery</code>源码的测试代码，在其<code>test/unit</code>目录下，对各个模块如<code>ajax</code>，<code>animation</code>等测试用例就是按文件进行管理的。</p>
<p>举例来说，模型类一般会提供CRUD的接口，可以组织对增删查改四个测试用例集合；就查找来讲，又可以单独测试<code>where</code>，<code>order</code>，<code>limit</code>等接口；拿where来讲，又需要测试默认<code>where(id, 1)</code>和<code>where(id, &quot;&gt;&quot;, 1)</code>这样的分支情形。总之，按层次来组织测试用例可以更清晰的帮助我们测试代码，避免遗漏某些地方，也是下面要提到的。</p>
<h3 id="如何相信测试用例"><a href="#如何相信测试用例" class="headerlink" title="如何相信测试用例"></a>如何相信测试用例</h3><p>如果测试代码本身有问题，那么测试不仅毫无意义，还会浪费更多的调试时间（调试源码，调试测试代码），因此，我们必须确保测试用例的正确性。关于这个问题，知乎上有一个回到：<a href="https://www.zhihu.com/question/25158368" target="_blank" rel="external">如何保证测试用例又少又准确?</a></p>
<p><strong>精简</strong></p>
<p>测试用例应当一眼就能看出其测试母的，尽量避免任何分支逻辑，因为我们需要的只是传入确定的参数，断言预期的结果而已，对于分支的测试应当另外写测试用例，而不是在同一个测试用例中增加逻辑操作。</p>
<p><strong>考虑全面，逐步完善</strong></p>
<p>测试用例需要尽可能考虑全面，避免遗漏某些分支；此外在接口的使用过程中如果出现了超出预期的结果，也可以回头补充测试用例。换句话说，测试也是一个逐渐完善的过程，我是在边开发边测试的，即完成一个接口就立即测试，遇见后面接口调整的时候（比如参数位置，输出结果格式化等），会回过头来重新调整测试用例。</p>
<h3 id="如何写断言"><a href="#如何写断言" class="headerlink" title="如何写断言"></a>如何写断言</h3><p>断言就是断定程序在这个条件下必定会输出的结果，断言的正确与否直接影响测试用例是否通过，一个好的断言的结果应该是固定的，即测试用例本身没有问题的情况下，无论运行多少次，都会得到统一的结果：要么通过，要么失败。</p>
<p>这个问题在我写测试用例的时候十分纠结，因此并不能保证数据库的数据是不会变化的，也就是说即使现在<code>id=1</code>的数据必定会返回<code>root</code>，在将来的某个时候数据发生改变，则这个断言必定失败。这种“硬编码”的形式明显是很不合理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">promiseDescribe(&quot;=&quot;, function (globalVal, done) &#123;</div><div class="line">    admin.where(&quot;id&quot;, 1).select().then((res) =&gt; &#123;</div><div class="line">        globalVal.name = res[0].name;</div><div class="line">        done();</div><div class="line">    &#125;);</div><div class="line">&#125;, function (globalVal) &#123;</div><div class="line">    it(&quot;&apos;id = 1&apos; should return root account&quot;, function () &#123;</div><div class="line">        assert.equal(&quot;root&quot;, globalVal.name);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>也许使用钩子函数，在用例执行之前插入数据，然后再测试查询并将结果与插入的数据进行比较要更合理一些。但是这样测试用例就会加入大量的逻辑代码，测试的时间也会更长~</p>
<p>总之，如何写好断言不是一件简单的事情。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于单元测试这块也是刚接触，上面的整理会有理解错误和遗漏的地方，后面再回来填（这个梗我都用了无数次了，貌似很少有填坑成功的~）。不过单元测试对于开发而言确实十分有帮助，在开发完成之后跑一通测试，看见满屏幕的勾，成就感简直爆棚，哈哈。</p>
<p>磨刀不误砍柴工，不要嫌写测试用例麻烦。PS：今后也会尝试一些其他的测试框架，以及了解框架的一些原理，总之，要想正儿八经的写代码，单元测试时必不可少的（不只是写JS哦）。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/代码格式" class="article_tag">#代码格式</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#单元测试"><span class="toc-number">1.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mocha使用"><span class="toc-number">2.</span> <span class="toc-text">mocha使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">2.2.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#describe和it"><span class="toc-number">2.2.1.</span> <span class="toc-text">describe和it</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#钩子函数"><span class="toc-number">2.2.2.</span> <span class="toc-text">钩子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#done"><span class="toc-number">2.2.3.</span> <span class="toc-text">done</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#描述符"><span class="toc-number">2.2.4.</span> <span class="toc-text">描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断言"><span class="toc-number">2.3.</span> <span class="toc-text">断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试用例"><span class="toc-number">3.</span> <span class="toc-text">测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何组织测试用例"><span class="toc-number">3.1.</span> <span class="toc-text">如何组织测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何相信测试用例"><span class="toc-number">3.2.</span> <span class="toc-text">如何相信测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何写断言"><span class="toc-number">3.3.</span> <span class="toc-text">如何写断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>