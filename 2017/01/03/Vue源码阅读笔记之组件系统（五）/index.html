<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">Vue源码阅读笔记之组件系统（五）</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/1/3 12:34:43</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>这是”Vue源码阅读笔记”系列第五篇文章。在之前我们分析了Vue的模板编译和渲染过程，以及响应式数据的原理，但是却有意识地避开了一个很重要的地方：<strong>组件</strong>。组件系统是Vue最强大的功能之一，接下来我们就从源码中，一步步揭开组件的神秘面纱。</p>
<a id="more"></a>
<p>参考：</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="external">官方文档：组件</a></li>
</ul>
<h2 id="组件化的目的"><a href="#组件化的目的" class="headerlink" title="组件化的目的"></a>组件化的目的</h2><p>在了解Vue的组件系统实现之前，先结合之前的使用，思考一下为什么要使用组件的概念来构建应用。</p>
<p>写了很长一段时间的烂代码，我先谈谈自己关于好代码的认知：好代码应该是结构清晰、易维护、可扩展的。</p>
<p>Vue的组件系统可以让我们用搭积木一样的方式来搭建web应用。</p>
<p>在后端的模板引擎中，一般会提供模板继承<code>@extends</code>和模板引入<code>@include</code>的功能，从而实现模板的共用，便于开发和维护，实际上可以找到组件化的影子。</p>
<p>PS：这里推荐王垠的一篇文章:<a href="http://www.jianshu.com/p/7645a5ea7f46" target="_blank" rel="external">编程的智慧</a>。在这篇文章的“写模块化的代码”这章，提到了如何达到很好的模块化（貌似与本文不是很相关~）。</p>
<h2 id="单个组件"><a href="#单个组件" class="headerlink" title="单个组件"></a>单个组件</h2><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局注册，通过Vue.component方法</span></div><div class="line"><span class="keyword">let</span> TestCom = Vue.extend(&#123;</div><div class="line">	template: <span class="string">'&lt;h1&gt;This is Test component!&lt;/h1&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">Vue.component(<span class="string">'testCom'</span>, TestCom)</div><div class="line"></div><div class="line"><span class="comment">// 局部注册，通过配置参数的components属性</span></div><div class="line"><span class="keyword">let</span> localCom = &#123;</div><div class="line">  template: <span class="string">`&lt;h1&gt;This is local component!&lt;/h1&gt;`</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  components: &#123;localCom&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后就可以在其他模板中通过组件名（比如<code>&lt;test-com&gt;</code>）使用组件了。实际上更常使用的方式是直接通过配置参数进行注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'testCom'</span>, &#123;</div><div class="line">	template: <span class="string">'&lt;h1&gt;This is Test component!&lt;/h1&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么，我们从<code>Vue.component</code>方法入手，从<code>initGlobalAPI-&gt;initAssetRegisters</code>找到其实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/global-api/assets.js</span></div><div class="line">Vue[<span class="string">"component"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">   id: string, <span class="regexp">//</span> 组件id</span></span></div><div class="line"><span class="function"><span class="params">   definition: Function | Object</span></span></div><div class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isPlainObject(definition)) &#123;</div><div class="line">      definition.name = definition.name || id</div><div class="line">      <span class="comment">// 在initGlobalAPI设置了Vue.options._base = Vue;</span></div><div class="line">      definition = <span class="keyword">this</span>.options._base.extend(definition)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.options[<span class="string">"component"</span>+<span class="string">"s"</span>][id] = definition</div><div class="line">    <span class="keyword">return</span> definition</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剥离了干扰代码，可以发现<code>Vue.component</code>方法十分简单，如果是<code>definition</code>配置对象参数则调用<code>Vue.extend</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/global-api/extend.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initExtend</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</div><div class="line">  Vue.cid = <span class="number">0</span></div><div class="line">  <span class="keyword">let</span> cid = <span class="number">1</span></div><div class="line"></div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">	</div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现继承</span></div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">// 下面省略一些合并的属性和方法</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">   </div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现<code>Vue.extend</code>返回一个继承自Vue的新的构造函数，这样就可以解释为什么每个组件可以当作vm实例了。</p>
<p>OK，现在我们了解了注册组件的过程，实际上就是生成了一个新的子类构造函数，并与<code>Vue.component</code>方法的第一个参数进行映射绑定（作为组件id）。那么注册完组件之后，组件对象是如何实例化然后挂载到父元素上的呢？</p>
<h3 id="组件实例"><a href="#组件实例" class="headerlink" title="组件实例"></a>组件实例</h3><p>在完成组件的注册之后，在模板中以标签的形式引入组件id即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">test-com</span>&gt;</span><span class="tag">&lt;/<span class="name">test-com</span>&gt;</span>    </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>看来我们寻找的答案需要到模板渲染的地方去寻找。先打印一下模板编译后的<code>render</code>函数看看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ƒ anonymous() &#123;</div><div class="line">	<span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">return</span> _c(</div><div class="line">        <span class="string">"div"</span>,</div><div class="line">        &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">"app"</span> &#125; &#125;,</div><div class="line">        [_c(<span class="string">"h1"</span>, [_v(_s(msg))]), _v(<span class="string">" "</span>), _c(<span class="string">"test-com"</span>)],</div><div class="line">        <span class="number">1</span></div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到了<code>_c(&quot;test-com&quot;)</code>，看来也是把组件当作了跟div一样的普通标签，去看一看<code>_c</code>函数（即<code>createElement</code>）的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/render.js</span></div><div class="line"><span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></div><div class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</div><div class="line"></div><div class="line"><span class="comment">// /src/core/vdome/create-element.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  context: Component,</span></span></div><div class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | Function | Object,</span></span></div><div class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></div><div class="line"><span class="function"><span class="params">  children?: any,</span></span></div><div class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">  <span class="comment">// 这里省略一些对参数的整理</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// 根据tag生成不同的vnode</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="comment">// resolveAsset会进行驼峰转换，格式化组件名称</span></div><div class="line">    <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</div><div class="line">      <span class="comment">// 如果是全局组件这里的Ctor就是对应的组件构造函数</span></div><div class="line">      <span class="comment">// 如果是局部组件这里的Ctor就是对应的组件options</span></div><div class="line">      vnode = createComponent(Ctor, data, context, children, tag)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// .. 生成其他形式的VNode</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/vdom/create-component.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></div><div class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></div><div class="line"><span class="function"><span class="params">  context: Component,</span></span></div><div class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  tag?: string</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> baseCtor = context.$options._base</div><div class="line">  <span class="comment">// 处理局部组件的options，并将其转换成构造函数形式</span></div><div class="line">  <span class="comment">// 后续的局部组件和全局组件的实例过程基本一致</span></div><div class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</div><div class="line">    Ctor = baseCtor.extend(Ctor)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 这里先省略了异步组件 async component</span></div><div class="line">  <span class="keyword">let</span> asyncFactory</div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  data = data || &#123;&#125;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</div><div class="line"></div><div class="line">  <span class="comment">// 生路函数组件functional component</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> listeners = data.on</div><div class="line">  data.on = data.nativeOn</div><div class="line"></div><div class="line">  <span class="comment">// 这里将componentVNodeHooks对象上的方法合并到data.hook对象上</span></div><div class="line">  mergeHooks(data)</div><div class="line">  <span class="comment">// return a placeholder vnode</span></div><div class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</div><div class="line">  <span class="comment">// 返回占位的vnode，需要注意这里的构造参数</span></div><div class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</div><div class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</div><div class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</div><div class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</div><div class="line">    asyncFactory</div><div class="line">  )</div><div class="line">  <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的过程我们应该理解了全局组件和局部组件的问题：</p>
<ul>
<li>全局组件是先注册并缓存其构造函数</li>
<li>局部组件是通过<code>resolveAsset</code>获取组件的options然后生成其构造函数</li>
</ul>
<p>实际上其他资源如<code>directive</code>的全局和局部注册，也可以参照这里的组件进行理解。</p>
<p>可以看见的是，<code>createComponent</code>函数只是将组件当作一个VNode返回而已，那么我们去<code>patch</code>函数中寻找答案。</p>
<h3 id="组件渲染"><a href="#组件渲染" class="headerlink" title="组件渲染"></a>组件渲染</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/vdom/patch.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> i = vnode.data</div><div class="line">    <span class="comment">// 只有组件带vnode.data属性</span></div><div class="line">    <span class="keyword">if</span> (isDef(i)) &#123;</div><div class="line">      <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</div><div class="line">      <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</div><div class="line">        <span class="comment">// 调用vnode.data.hook.init方法</span></div><div class="line">        <span class="comment">// 而该方法是前面mergeHooks中合并的componentVNodeHooks上的</span></div><div class="line">        i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>, parentElm, refElm)</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// hook.init方法会调用组件构造函数并实例化组件对象，</span></div><div class="line">      <span class="comment">// 并挂载到vnode.componentInstance属性上</span></div><div class="line">      <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</div><div class="line">        initComponent(vnode, insertedVnodeQueue)</div><div class="line">        <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</div><div class="line">          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>然后找到对应的<code>componentVNodeHooks.init</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/vdom/create-component.js</span></div><div class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</div><div class="line">  init (</div><div class="line">    vnode: VNodeWithData,</div><div class="line">    hydrating: boolean,</div><div class="line">    parentElm: ?Node,</div><div class="line">    refElm: ?Node</div><div class="line">  ): ?boolean &#123;</div><div class="line">    <span class="keyword">if</span> (!vnode.componentInstance || vnode.componentInstance._isDestroyed) &#123;</div><div class="line">  	  <span class="comment">// 调用组件构造函数，实例化组件对象</span></div><div class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</div><div class="line">        vnode,</div><div class="line">        activeInstance,</div><div class="line">        parentElm,</div><div class="line">        refElm</div><div class="line">      )</div><div class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</div><div class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></div><div class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 下面这个注释<span class="number">233</span></span></span></div><div class="line"><span class="function"><span class="params">  vnode: any, <span class="regexp">//</span> we know it<span class="string">'s MountedComponentVNode but flow doesn'</span>t</span></span></div><div class="line"><span class="function"><span class="params">  parent: any, </span></span></div><div class="line"><span class="function"><span class="params">  parentElm?: ?Node,</span></span></div><div class="line"><span class="function"><span class="params">  refElm?: ?Node</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</div><div class="line">    _isComponent: <span class="literal">true</span>,</div><div class="line">    parent,</div><div class="line">    _parentVnode: vnode,</div><div class="line">    _parentElm: parentElm || <span class="literal">null</span>,</div><div class="line">    _refElm: refElm || <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 这里省略了 inline-template render functions</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  </div><div class="line">  <span class="comment">// 终于找到了对应的组件构造函数</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在整理模板渲染的时候没有详细分析<code>vm.__patch__</code>方法的实现，主要也是考虑到了组件渲染的问题。对于组件的生成过程我们应该有了大致的印象，整理一下顺序：</p>
<ul>
<li>首先注册组件，实际上是生成继承自Vue的组件构造函数，然后在模板中通过组件标签引入组件</li>
<li>然后在编译模板时，根据标签名判断如果是否是组件，如果是则调用<code>createComponent</code>生成对应VNode</li>
<li>在patch时，将虚拟DOM树中的VNode转换为实际DOM节点，如果节点是已注册的组件，则调用<code>vnode.data.hook.init</code>方法，调用对应组件的构造函数，获得组件实例，然后将其挂载到父组件上。</li>
</ul>
<p>至此，我们了解了单个组件从构造函数到实例化对象然后挂载到父元素的过程，接下来就应该看看多组件之间的问题了。</p>
<h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p>组件本身就应该像搭积木一样使用，彼此独立方便替换，但是不可避免地，组件之间也需要相互通信，配合使用，即一个组件应当封装内部实现，暴露外部接口。Vue的实现是</p>
<blockquote>
<p>在 Vue 中，父子组件的关系可以总结为 <strong>prop 向下传递，事件向上传递</strong></p>
</blockquote>
<h3 id="向下数据传递"><a href="#向下数据传递" class="headerlink" title="向下数据传递"></a>向下数据传递</h3><p>子组件通过配置<code>props</code>属性声明需要接收的数据，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'testCom'</span>, &#123;</div><div class="line">    props:[<span class="string">'msg'</span>],</div><div class="line">    template: <span class="string">`&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;`</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后在父组件中通过组件标签的属性传入相应的值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">test-com</span> <span class="attr">:msg</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">test-com</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面来分析整个过程</p>
<p><strong>合并属性参数</strong></p>
<p>还记得<code>Vue.proptype._init</code>中的<code>mergeOptions</code>方法吗？我们来看看他是如何处理<code>props</code>配置的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// /src/core/util/options.js</div><div class="line">export function mergeOptions (</div><div class="line">  parent: Object,</div><div class="line">  child: Object,</div><div class="line">  vm?: Component</div><div class="line">): Object &#123;</div><div class="line">  if (typeof child === 'function') &#123;</div><div class="line">    child = child.options</div><div class="line">  &#125;</div><div class="line">  // 这里处理配置参数的props属性	</div><div class="line">  normalizeProps(child, vm)</div><div class="line">  // 后面省略</div><div class="line">&#125;</div><div class="line"></div><div class="line">function normalizeProps (options: Object, vm: ?Component) &#123;</div><div class="line">  const props = options.props</div><div class="line">  const res = &#123;&#125;</div><div class="line">  if (Array.isArray(props)) &#123;</div><div class="line">    // 将数组转换成 &#123;key:&#123;type:null&#125;&#125;的形式...</div><div class="line">  &#125; else if (isPlainObject(props)) &#123;</div><div class="line">    // 对对象属性名进行camelize处理...</div><div class="line">  &#125; </div><div class="line">  options.props = res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上只是对props做了类型处理，并统一转换成Object格式。比如上面我们传入<code>[&#39;msg&#39;]</code>，处理为<code>{msg:{type:null}}</code>形式</p>
<p><strong>获取属性值</strong></p>
<p>那么父组件的属性是如何传递给子组件的呢？我们知道使用方法是通过在模板中的组件标签中通过传递属性值，那么回到<code>createComponent</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/vdom/create-component.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 构造参数省略</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// 这里获取从父组件传递的属性值</span></div><div class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</div><div class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</div><div class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</div><div class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;, <span class="comment">// 这里将propsData传入VNode</span></div><div class="line">    asyncFactory</div><div class="line">  )</div><div class="line">  <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/vdom/helpers/extract-props.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">extractPropsFromVNodeData</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  data: VNodeData,</span></span></div><div class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  tag?: string</span></span></div><div class="line"><span class="function"><span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="comment">// 检验属性值的类型和默认值在组件内部执行</span></div><div class="line">  <span class="keyword">const</span> propOptions = Ctor.options.props</div><div class="line">  <span class="keyword">const</span> res = &#123;&#125;</div><div class="line">  <span class="comment">// attrs即从子组件标签上解析获得的属性对象，包括属性和值</span></div><div class="line">  <span class="keyword">const</span> &#123; attrs, props &#125; = data</div><div class="line">  <span class="comment">// 这里遍历props属性，用attrs的值进行填充</span></div><div class="line">  <span class="keyword">if</span> (isDef(attrs) || isDef(props)) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propOptions) &#123;</div><div class="line">      <span class="keyword">const</span> altKey = hyphenate(key)</div><div class="line">      checkProp(res, props, key, altKey, <span class="literal">true</span>) ||</div><div class="line">      checkProp(res, attrs, key, altKey, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回填充后的结果</span></div><div class="line">  <span class="keyword">return</span> res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看见在<code>extractPropsFromVNodeData</code>方法中通过遍历<code>attrs</code>和<code>props</code>，从而获取从父组件传递的<code>props</code>属性值，然后将获得的数据挂载到<code>VNode</code>的<code>componentOptions</code>参数上。</p>
<p><strong>属性更新</strong></p>
<p>拿到数据之后，剩下要做的就是监听props实现属性值的双向绑定了。</p>
<p>与data不同的是，处理props时</p>
<ul>
<li>父组件初始化属性值并传递给子组件</li>
<li>父组件属性值变化，直接修改子组件的数据</li>
</ul>
<p>先停下来思考一下，该如何实现上面的父组件数据变化，修改子视图的内容呢？回想前两章的内容，根据响应式数据和模板渲染，来梳理一下流程</p>
<ul>
<li>实例化父组件的时候，通过<code>initData</code>方法劫持data对象的属性访问符并在每个属性的<code>getter</code>中收集依赖</li>
</ul>
<ul>
<li>父组件在<code>mountComponent</code>中，通过传入<code>updateComponent</code>方法实例化<code>Watcher</code>对象</li>
<li><code>updateComponent</code>内部调用的<code>vm._render</code>和<code>vm._update</code>方法生成虚拟DOM树，并在patch中转换成真正的DOM树并挂载到页面上</li>
<li>数据变化时会调用属性的<code>setter</code>，触发<code>Watcher</code>对象的update，然后再次调用<code>updateComponent</code>，生成新的虚拟DOM树</li>
<li>通过diff和patch，为已修改的节点生成新的DOM节点，然后挂载到父元素上。</li>
</ul>
<p>也就是说，父组件的数据发生了改变，会重新调用渲染函数并使用更新后的数据填充模板，在渲染子模板时再次调用<code>createComponent</code>，此时中的<code>attrs</code>也会改变，获取到的<code>props</code>也随之更新，然后更新子组件的视图。这就是上面提到的<strong>父组件直接修改子组件的数据</strong></p>
<p>实际上我们只需要把子组件当做是一个普通的标签即可，他们的更新与父组件模板中其他的节点更新是一样的。</p>
<p><strong>属性的响应式与单向数据流</strong></p>
<p>然而在<code>Vue.proptype._init</code>的<code>initState</code>方法中除了我们之前分析的<code>initData</code>，还可以找到<code>initProps</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /src/core/instance/state.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  vm._watchers = []</div><div class="line">  <span class="keyword">const</span> opts = vm.$options</div><div class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</div><div class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</div><div class="line">  <span class="keyword">const</span> keys = vm.$options._propKeys = []</div><div class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</div><div class="line">  </div><div class="line">  observerState.shouldConvert = isRoot</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</div><div class="line">    keys.push(key)</div><div class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</div><div class="line">    </div><div class="line">    defineReactive(props, key, value, () =&gt; &#123;&#125;)</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</div><div class="line">      proxy(vm, <span class="string">`_props`</span>, key)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  observerState.shouldConvert = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的<code>defineReactive</code>，我们可以向操作data属性一样通过修改props属性来更新子组件的视图，但是由于Vue的<strong>单向数据流</strong>，这样操作会抛出一个警告</p>
<blockquote>
<p>每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你<strong>不应该</strong>在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</p>
</blockquote>
<p>不过即使忽略这个警告，我们也可以发现，父组件的数据更新会影响子组件，而子组件修改props，却不会修改父组件，这是因为<code>extractPropsFromVNodeData</code>中是通过<strong>浅复制</strong>将attrs传递给props的。</p>
<p>浅复制意味着在子组件中对<strong>对象和数组</strong>的props进行修改还是会影响父组件，这就违背了单向数据流的设计。</p>
<p><strong>属性代理</strong></p>
<p>在组件构造函数<code>Vue.extend</code>中可以发现<code>initProps</code>对props对象进行了代理，这样就可以在组件中通过<code>this.xx</code>对props进行访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">	initProps(Sub)</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">Comp</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> props = Comp.options.props</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</div><div class="line">    <span class="comment">// 对数据进行代理，在组件中可以通过this.xx访问</span></div><div class="line">    proxy(Comp.prototype, <span class="string">`_props`</span>, key)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###向上事件通知 </p>
<p>上面提到了单向数据流，单向数据流的设计是为了防止子组件无意间修改父组件的状态。因此在良好的设计下，</p>
<ul>
<li>子组件的数据修改和视图更新时封闭的</li>
<li>子组件通过触发事件实现对父组件的通知</li>
</ul>
<p>通过事件，子组件和它的外部完全解耦了。它所做的只是报告自己的内部事件，因为父组件可能会关心这些事件。</p>
<p>在上一章我们简单分析了在<code>eventsMixin(Vue)</code>中为Vue原型对象添加的四个事件方法及其内部实现。每个vm实例都有<code>$on</code>、<code>$once</code>、<code>$off</code>和<code>$emit</code>四个事件api。那么父组件是如何在子组件上注册事件的呢？</p>
<p><strong>事件注册</strong></p>
<p>通过断点理清了自定义事件的注册流程，相关的代码有点长，这里就不粘贴了。</p>
<ul>
<li>生成render函数时，会将组件标签上的的<code>v-on</code>指令解析到配置对象的on属性</li>
</ul>
<ul>
<li>render函数执行时，遇见组件标签会调用<code>createComponent</code>生成对应的vnode，其中on属性会挂载到<code>vnode.componentOptions.listeners</code>上</li>
<li>patch函数执行时，会调用<code>createComponent</code>并传入对应的vnode，如果是组件会调用对应的组件构造函数</li>
<li>在组件实例化的<code>_init(option)</code>过程中，合并配置参数时会调用<code>initInternalComponent</code>，并添加<code>option._parentListeners = vnodeComponentOptions.listeners</code> </li>
<li>然后在<code>initEvents</code>中，会根据<code>option._parentListeners</code>调用<code>updateComponentListeners</code>为组件实例注册相关的事件，其中的<code>add</code>方法即<code>$once</code>和<code>$on</code>快捷封装</li>
</ul>
<p>可以看见，通过上面的流程，可以把父组件的事件处理函数注册到子组件的事件上，然后只需要在子组件中手动触发<code>vm.$emit(eventName)</code>就可以调用父组件的方法了。</p>
<p><strong>组件上的原生事件</strong></p>
<p>在模板解析的时候对于组件上和常规标签上的<code>v-on</code>指令处理不一样的（虽然他们都是被解析到render函数配置参数的on属性上），在<a href="/article/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%EF%BC%88%E5%9B%9B%EF%BC%89#4. %E4%BA%8B%E4%BB%B6">语法细节</a>这一章我们整理了原生事件处理函数的处理方式，会调用<code>addEventListener</code>进行注册。但是在组件上<code>@click</code>等原生事件也会被当作自定义事件处理，需要手动触发才会生效。</p>
<p>那么，如果需要为子组件绑定原生的事件处理函数应该怎么做呢？其实只需要添加<code>.native</code>修饰符即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">test-com</span> <span class="attr">:message</span>=<span class="string">"msg"</span> @<span class="attr">click.native</span>=<span class="string">"listenChild"</span> @<span class="attr">done</span>=<span class="string">"done"</span>&gt;</span><span class="tag">&lt;/<span class="name">test-com</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样相关的指令会解析到配置参数的<code>nativeOn</code>属性上面，然后通过<code>addEventListener</code>进行注册。</p>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p><strong>插槽的使用</strong></p>
<p>在大部分情况下，组件应该是封装良好的，但凡事无绝对，在开发中也会遇到某些特殊情况。</p>
<p>举个例子，实现一个通用的选项卡组件，我们需要封装选项卡切换的逻辑，并在选项卡切换通知父元素。但是每个选项卡的内容，可能是由父组件控制的。如何解决这个问题呢</p>
<p>Vue提供了<a href="https://cn.vuejs.org/v2/guide/components.html#%E4%BD%BF%E7%94%A8%E6%8F%92%E6%A7%BD%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9" target="_blank" rel="external">slot</a>来实现内容分发的功能，即向子组件中动态插入模板内容，且插入的数据作用域由父元素控制</p>
<blockquote>
<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p>
</blockquote>
<p>但在有时候，确实需要在插槽中访问子组件的数据，比如一个通用的列表组件，列表的部分内容如序号，操作按钮等是公共的，而列表展示的具体数据样式有差异（比如用户列表项和商品列表项的内容和排版），此时每个的渲染模板来自于父组件（具体的列表），但列表项中的序号等数据需要从子组件获取。</p>
<p>考虑到上面这种使用情形，Vue还提供了<strong>作用域插槽</strong>的功能，通过指定<code>slot-scope</code>需要从子组件获取的数据</p>
<p><strong>插槽的实现</strong></p>
<p>接下来我们来看看在模板编译时是如何处理slot的，同理，我们先写一个最简单的插槽</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">test-com</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span>hello slot<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">test-com</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'slotCom'</span>, &#123;</div><div class="line">    template: <span class="string">`</span></div><div class="line"><span class="string">        &lt;h1&gt;</span></div><div class="line"><span class="string">        	&lt;slot&gt;default slot&lt;/slot&gt;</span></div><div class="line"><span class="string">        &lt;/h1&gt;`</span>,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>老规矩，从渲染函数开始</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父元素的渲染函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">return</span> _c(</div><div class="line">      <span class="string">"div"</span>,</div><div class="line">      &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">"app"</span> &#125; &#125;,</div><div class="line">      [_c(<span class="string">"slot-com"</span>, [_t(<span class="string">"default"</span>, [_v(<span class="string">"hello slot"</span>)])], <span class="number">2</span>)],</div><div class="line">      <span class="number">1</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 子组件的渲染函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">return</span> _c(<span class="string">"h1"</span>, [_t(<span class="string">"default"</span>, [_v(<span class="string">"default slot"</span>)])], <span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看见，在render函数中通过<code>_t</code>辅助函数将对应的slot节点转换成子节点，然后通过<code>_c</code>函数进行渲染。我们定位到<code>renderSlot</code>辅助函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  name: string,</span></span></div><div class="line"><span class="function"><span class="params">  fallback: ?Array&lt;VNode&gt;,</span></span></div><div class="line"><span class="function"><span class="params">  props: ?Object,</span></span></div><div class="line"><span class="function"><span class="params">  bindObject: ?Object</span></span></div><div class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">const</span> scopedSlotFn = <span class="keyword">this</span>.$scopedSlots[name]</div><div class="line">  <span class="keyword">let</span> nodes</div><div class="line">  <span class="keyword">if</span> (scopedSlotFn) &#123;</div><div class="line">  	<span class="comment">// 作用域插槽</span></div><div class="line">    props = props || &#123;&#125;</div><div class="line">    <span class="keyword">if</span> (bindObject) &#123;</div><div class="line">      props = extend(extend(&#123;&#125;, bindObject), props)</div><div class="line">    &#125;</div><div class="line">    nodes = scopedSlotFn(props) || fallback</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 具名插槽</span></div><div class="line">    <span class="keyword">const</span> slotNodes = <span class="keyword">this</span>.$slots[name]</div><div class="line">    <span class="keyword">if</span> (slotNodes) &#123;</div><div class="line">      slotNodes._rendered = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 直接传入的vnode节点</span></div><div class="line">    nodes = slotNodes || fallback</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> target = props &amp;&amp; props.slot</div><div class="line">  <span class="keyword">if</span> (target) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$createElement(<span class="string">'template'</span>, &#123; <span class="attr">slot</span>: target &#125;, nodes)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 直接返回对应的vnode</span></div><div class="line">    <span class="keyword">return</span> nodes</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在解析模板的时候，会通过<code>renderSlot</code>函数将对应的插槽解析为vnode，然后在<code>createChildren</code>进行渲染。</p>
<h2 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h2><p>上面整理了父子组件之间的单向数据流通信的工作原理，即<code>props</code>和<code>_parentListeners</code>的运行机制。那么，非父子组件之间的通信该怎么实现呢？</p>
<p>换个角度思考一下，所谓通信就是多个组件间共享某些数据</p>
<h3 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h3><p>一种常见的做法是通过一个空的Vue对象来管理数据，下面是一个简单的例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">btn-a</span>&gt;</span><span class="tag">&lt;/<span class="name">btn-a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> btnA = Vue.component(<span class="string">"btn-a"</span>, &#123;</div><div class="line">    template: <span class="string">`&lt;button @click="test"&gt;click&lt;/button&gt;`</span>,</div><div class="line">    methods: &#123;</div><div class="line">        test()&#123;</div><div class="line">            <span class="keyword">this</span>.$root.Bus.$emit(<span class="string">"btnclick"</span>, <span class="string">"greet from btna"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">let</span> comB = Vue.component(<span class="string">"com-b"</span>, &#123;</div><div class="line">    template: <span class="string">`&lt;h1&gt;&#123;&#123;greet&#125;&#125;&lt;/h1&gt;`</span>,</div><div class="line">    props: &#123;</div><div class="line">        msg: &#123;</div><div class="line">            type: <span class="built_in">String</span>,</div><div class="line">            <span class="keyword">default</span>: <span class="string">"hello"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    created()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"created"</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    mounted()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"mounted"</span>);</div><div class="line">        <span class="keyword">this</span>.$root.Bus.$on(<span class="string">"btnclick"</span>, (e)=&gt;&#123;</div><div class="line">            <span class="keyword">this</span>.greet = e;</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    data()&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            greet: <span class="string">"hhh"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">"#app"</span>,</div><div class="line">    data: &#123;</div><div class="line">        <span class="comment">// 这个空的vue对象来做事件总线</span></div><div class="line">        Bus: <span class="keyword">new</span> Vue()</div><div class="line">    &#125;,</div><div class="line">    components: &#123;btnA, comB&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>如果整个应用比较复杂，则可能需要定义多个空的Vue对象来管理不同组件之间的通信，此时我们需要更专业的<a href="https://cn.vuejs.org/v2/guide/state-management.html" target="_blank" rel="external">状态管理</a>，Vue提供了Vuex这个库，关于<a href="https://github.com/vuejs/vuex" target="_blank" rel="external">Vuex</a>的分析，咱们后面再弄</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这章简单这里了Vue组件的相关知识。还有一些诸如异步组件、递归组件等没有一一研究了。了解组件的实现只是实现模块化的第一步，我觉得，如何将业务拆分成合适的组件是一个更难且更重要的任务，这这有在大量的实践中才能理解，因此任重而道远啊。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/Vue" class="article_tag">#Vue</a>
        
        <a href="/tags/源码分析" class="article_tag">#源码分析</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#组件化的目的"><span class="toc-number">1.</span> <span class="toc-text">组件化的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单个组件"><span class="toc-number">2.</span> <span class="toc-text">单个组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注册组件"><span class="toc-number">2.1.</span> <span class="toc-text">注册组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件实例"><span class="toc-number">2.2.</span> <span class="toc-text">组件实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件渲染"><span class="toc-number">2.3.</span> <span class="toc-text">组件渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父子组件通信"><span class="toc-number">3.</span> <span class="toc-text">父子组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#向下数据传递"><span class="toc-number">3.1.</span> <span class="toc-text">向下数据传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slot插槽"><span class="toc-number">3.2.</span> <span class="toc-text">slot插槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非父子组件通信"><span class="toc-number">4.</span> <span class="toc-text">非父子组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于事件"><span class="toc-number">4.1.</span> <span class="toc-text">基于事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex"><span class="toc-number">4.2.</span> <span class="toc-text">vuex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>