<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">webpack折腾记（一）</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/5/27 0:31:14</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/工具" class="hover-highlight">工具</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>gulp用了很长一段时间了，也挺顺手的，只是最近一直在用<code>vue-cli</code>进行开发，被其各种方便的特性给惊呆了。然而归根结底就是gulp和webpack的比较，作为新一代的前端流程开发工具（现在也不新了），还是大概了解一下吧。</p>
<a id="more"></a>
<p>参考：</p>
<ul>
<li><a href="https://webpack.js.org/guides/get-started/" target="_blank" rel="external">webpack官方文档</a></li>
<li><a href="http://www.jb51.net/article/96646.htm" target="_blank" rel="external">webpack常用配置项配置文件介绍</a></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="webpack与gulp"><a href="#webpack与gulp" class="headerlink" title="webpack与gulp"></a>webpack与gulp</h3><p>起初断断续续学了一段时间的webpack，后来终究还是给放弃了，因为之前的项目比较小，用gulp写两个任务搭好环境就可以了（这大概就是温水煮青蛙，不愿离开稳定的环境罢！）。</p>
<p>现在来看看webpack和gulp之间的区别：</p>
<ul>
<li><code>gulp</code>是一个自动化工具，其工作流程是基于文件流的，代替人工手动操作，实现自动化开发</li>
<li><code>webpack</code>是一个打包工具，将项目中的各种文件合并打包，实现模块化开发</li>
</ul>
<p>我认为在概念上，gulp和webpack并不冲突，尽管他们可以借助自身的插件或loader实现许多类似的功能，比如：</p>
<ul>
<li>文件压缩打包</li>
<li>css预编译器</li>
<li>热更新环境</li>
</ul>
<p>那么，为什么我现在要重新折腾webpack呢？因为之前一直在纠结开发过程中的样式表管理，脚本管理等问题，也写过“BEM命名”，requireJS使用方法等文章，说到底就是模块化开发的问题。webpack既能完成大部分自动化功能，更重要的是他解决了模块化开发的问题！但是口说无凭，webpack到底是如何解决模块化的问题的呢？</p>
<h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>为了实现模块化开发：</p>
<ul>
<li>在RequireJS中，我们使用<code>define</code>定义模块，使用<code>require</code>引入模块；</li>
<li>在scss中，我们将样式组件拆分成数个独立的<code>_*.scss</code>，使用<code>@import</code>按需引入相应组件。</li>
</ul>
<p>webpack是基于nodejs的，也就是说，我们可以使用CommonJS规范来管理JS模块。但是，样式表、图片和其他文件是怎么实现模块化管理的呢？注意，重点来了：webpack的核心思想就是<strong>将所有资源都视为JS模块，并允许我们通过相同的方式调用这些模块</strong>。</p>
<p>更明白一点讲，webpack把我们的项目当作一个主体，通过一个给定的主文件找到整个项目所有的依赖文件，将这些依赖文件进行处理之后统一打包成一个浏览器可识别的JS文件。是不是很神奇？下面让我们慢慢揭开它的神秘面纱。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>关于webpack的使用防范，网上也有大量的教程了，这里简单整理一下使用方法（PS：使用的是版本<code>v2.2.1</code>）。</p>
<h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>由于是将多个资源模块打包成一个文件（打包成多个文件的做法后面会提到），这意味着我们的页面只需要调用这一个文件就够了。因此我们需要列出项目的依赖模块，这个列出资源列表的文件通常称作入口文件，我一般命名为<code>entry.js</code>（实际上入口文件可以不只一个哦）;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//demo1.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    writeHello()&#123;</div><div class="line">        <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">        oDiv.innerHTML = <span class="string">"&lt;h1&gt;This div came from demo1.js&lt;/h1&gt;"</span>;</div><div class="line">        <span class="built_in">document</span>.body.appendChild(oDiv);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="keyword">var</span> demo1 = <span class="built_in">require</span>(<span class="string">"./lib/demo1.js"</span>);</div><div class="line">demo1.writeHello();</div></pre></td></tr></table></figure>
<p>最后调用<code>webpack entry.js dist/bundle.js</code>进行打包，输出文件为<code>dist/bundle.js</code>。可以看见，采用的是跟NodeJS完全相同的模块语法，用文档的话来讲：</p>
<blockquote>
<p>Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。</p>
</blockquote>
<p>在我们的页面上只需要引入对应的<code>bundle.js</code>文件就可以了，如果使用equireJS，还必须得配置相关路径，最后使用<code>r.js</code>进行打包，所以这个确实方便得多。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>使用CommonJS风格调用js文件是无可厚非的，但是对于其他非js的文件，比如图片样式表等，webpack使用的方案是<code>loader</code>加载器，使用loader,就可以像调用JS模块一样使用其他类型的资源文件（官方的叫法是<code>any static resource</code>）。举个打包样式表的例子，准备一个css文件，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// css/demo1.css</div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  	<span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后安装对应loader:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm i style-loader css-loader -D</div></pre></td></tr></table></figure></p>
<p>接着在我们的入口文件引入对应的css资源，并配置相关loader，关于每个loader的作用下面马上讲解（顺道吐槽一下为啥是用<code>!</code>作为分割符呢？）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">"!style-loader!css-loader!./css/demo1.css"</span>);</div></pre></td></tr></table></figure></p>
<p>最后进行打包就可以了。此时打开页面<code>index.html</code>可以发现，样式表原来是作为<code>style</code>节点插入页面头部的，这是为什么呢？没错，就是上面的loader的作用。</p>
<ul>
<li><code>style-loader</code>：将css插入到页面的style标签</li>
<li><code>css-loader</code>：将 css 装载到 javascript</li>
</ul>
<p><strong>加载顺序</strong><br>细心的你应该会发现一个问题：为什么先写<code>style-loader</code>，然后写<code>css-loader</code>，最后才是<code>*.css</code>这个资源文件呢？正常情况下不是先加载css资源，然后将css资源装载到js，最后通过js将样式表节点插入页面上吗？</p>
<p>恭喜你！你发现了一个天大的秘密：<strong>loader的加载顺序实际上是从右向左的！</strong>这里跟gulp中的文件流的概念相似，多个loader之间的工作是基于文件流进行的，因此，<strong>必须确保loader的从右向左的加载顺序！</strong>不信你把上面两个loader顺序调换试试。</p>
<p><strong>相同文件配置</strong><br>有代码洁癖的你应该会发现第二个问题：如果需要打包多个样式表，那不是每次引入都必须为这些css文件配置对应的loader?没错，的确如此，webpack提供了按照文件格式批量配置loader的方案：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js dist/bundle.js --module-bind <span class="string">"css=style-loader!css-loader"</span></div></pre></td></tr></table></figure></p>
<p>看起来已经解决问题了。但是，每次都打包都配置这个长的参数真的好吗？webpack提供了一个更简单粗暴的方案：配置文件！</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在gulp中我们使用<code>gulpfile.js</code>加载模块，配置环境和定义任务，在webpack中我们在<code>webpack.config.js</code>中定义我们的配置，而最终需要执行的只是一个<code>webpack</code>打包指令就可以了。尽管这个配置文件仅仅只是一个简单的JS模块，但是相关的配置参数还是比较繁复的，这也正是学习webpack的一个难点。</p>
<p>实际上配置参数也是根据webpack本身的功能来进行的（这不废话吗？）只要了解了webpack几个主要特性，相关的配置就迎刃而解了。我这里先简单整理了初学者需要了解的配置参数，强烈推荐<a href="https://webpack.js.org/configuration/" target="_blank" rel="external">官方文档</a>。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径配置包括<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 入口文件路径</span></div><div class="line">entry: __dirname + <span class="string">"./entry.js"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 输入文件</span></div><div class="line">output: &#123;</div><div class="line">    path: __dirname + <span class="string">"/dist"</span>,</div><div class="line">    filename: <span class="string">"bundle.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>网上大量的教程都是关于<code>module.loaders</code>的配置，后来才发现那是webpack1的使用方法。在webpack2中，使用<code>module.rules</code>，个人认为这种配置方式更加直观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">    rules: [</div><div class="line">        &#123;	</div><div class="line">        	// 匹配规则</div><div class="line">            test: /\.css$/,</div><div class="line">            // 对应loader</div><div class="line">            loader: [&quot;style-loader&quot;, &quot;css-loader&quot;],</div><div class="line">            // 其他参数...</div><div class="line">            include: path.resolve(__dirname, &quot;style&quot;),</div><div class="line">            exclude: path.resolve(__dirname, &quot;node_modules&quot;),</div><div class="line">        &#125;,</div><div class="line">    ]</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>大部分情况下，我们只需要配置正确的loader就可以 了。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>此外还有一些不是特别常见的配置属性</p>
<ul>
<li><code>resolve</code>，配置模块的引入等，比如为模块取个别名</li>
<li><code>externals</code>，扩展模块库，比如直接引入CDN文件</li>
</ul>
<p>正确配置了相关的参数之后，打包的命令就只需要一个不带任何参数的<code>webpack</code>指令就可以了，或者使用<code>npm</code>指定一个打包命令<code>npm run build</code>之类的。</p>
<ul>
<li>大部分配置参数都可以是字符串或数组形式：为单参数时用字符串，为多参数时用数组</li>
<li>建立使用绝对路径配置文件相关路径，<code>path.resolve(__dirname, target)</code>，或者预先定义常量</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>loader只能让我们像加载js一样加载其他资源，但是还有某些特殊的需求，比如增加注释，打包多文件等，我们需要使用插件来完成。</p>
<p>来看一个简单的例子，在输出文件添加文档注释，这里使用webpack内置的插件<code>BannerPlugin</code>,通过配置文件的<code>plugins</code>参数进行配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">    new webpack.BannerPlugin(&quot;Author: txm, 2017-08-28&quot;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>在gulp中并没有loader的概念，因此整个工作是通过文档流合并在一起的。在webpack中，loader可以让我们处理各种格式的文件，而插件可以让我们完成自动化的工作。换句话说，一般情况下常见的文件格式都有其对应的loader进行处理，而具体的任务需求所需要的插件，只能靠自己平常去收集了（汗）…</p>
<h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>使用webpack可以显著提高开发效率，且只需要进行简单的配置即可，不需要像gulp一样去编写对应的任务。下面从样式表、脚本、热更新、文件处理等方面对相关的配置进行总结</p>
<h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>样式表的开发流程一般是</p>
<ul>
<li>使用scss编写源码，</li>
<li>然后对编译后的css文件进行处理，比如添加浏览器前缀</li>
<li>样式表中引用的外部文件，比如图片字体等，webpack也将他们识别为相应的模块，因此也必须配置对应的loader</li>
<li>如果需要将css打包进js文件，还必须使用前面提到的一些相关loader</li>
</ul>
<p><strong>常用loader</strong></p>
<ul>
<li><code>scss-loader</code>，编译scss文件</li>
<li><code>auto-prefixer</code>，自动处理浏览器前缀</li>
<li><code>px2rem</code>，将像素单位转换为rem单位</li>
<li><code>url-loader</code>，用来处理<code>background-image</code>的url问题，还可以将图片进行base64转码</li>
<li><code>css-loader</code>，让webpack加载css文件</li>
<li><code>style-loader</code>，将样式表输出到页面上</li>
</ul>
<p><strong>常用插件</strong><br>尽管使用<code>style-loader</code>将css一起打包到一个js文件看起来很酷，但是考虑到浏览器渲染流程，更通常是将样式表单独提出来，此时可以使用<code>extract-text-webpack-plugin</code>插件完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">	rules: [</div><div class="line">      &#123;</div><div class="line">          test: /\.css$/,</div><div class="line">          use: ExtractTextPlugin.extract(&#123;</div><div class="line">          		use: &quot;css-loader&quot;</div><div class="line">          &#125;)</div><div class="line">      &#125;</div><div class="line">	]</div><div class="line">,</div><div class="line">plugins: [</div><div class="line">    new ExtractTextPlugin(&quot;main.css&quot;),</div><div class="line">],</div></pre></td></tr></table></figure>
<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p>使用webpack编写脚本主要侧重两个方面：</p>
<ul>
<li>模块化</li>
<li>Babel语法转化</li>
</ul>
<p><strong>模块化</strong><br>将js代码拆分成多个模块（包括第三方库文件），然后按需引入，实现模块化的开发，并不需要我们像使用RequireJS一样还得配置路径，声明依赖等，webpack会自动处理这一切。如果想要引入CDN上面的脚本资源，必须现在页面上使用<code>script</code>标签引入，然后在配置文件的<code>externals</code>参数中进行配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">// webpack.config.js</div><div class="line">externals: &#123;</div><div class="line">	jquery: &quot;jQuery&quot; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的<code>&quot;jQuery&quot;</code>就是全局变量<code>jQuery</code>，查看编译后的文件，可以看见内部实现是<code>module.exports = jQuery</code>，也就是说引入jquery的这个文件是放在引入<code>bundle.js</code>的前面进行加载的，因为必须保证<code>bundle.js</code>能够访问到jQuery对象。在接下来的代码中就可以使用<code>var $ = require(&quot;jquery&quot;)</code>了。<br>个人觉得这里有点不合理，RequireJS可以在CDN文档加载失败之后调用备份的本地文件，此外这样的依赖顺序会导致浏览器的阻塞，在webpack这里我还没找到具体的处理措施，先挖个坑吧。</p>
<p><strong>babel</strong><br>实现babel转义需要安装</p>
<ul>
<li><code>babel-core</code>，babel功能文件</li>
<li><code>babel-preset-env</code>，根据配置环境智能转换JS代码的版本，而不是一股脑都转换为旧代码</li>
</ul>
<p>此外还需要对应的loader</p>
<ul>
<li><code>babel-loader</code></li>
</ul>
<p>然后添加对应的规则就可以了，甚至连<code>.babellrc</code>都不需要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    use: &#123;</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">        	presets: [&apos;env&apos;] // 配置需要编译的版本</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>在webpack中实现热更新也简单很多，首先全局安装<code>webpack-dev-server</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm i webpack-dev-server -g</div></pre></td></tr></table></figure></p>
<p>然后再运行就可以了，不用向gulp那样去配置<code>livereload</code>这些了，如果闲命令太长也可以在<code>package.json</code>中封装成npm命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server --progress --colors</div></pre></td></tr></table></figure></p>
<p>遇见热更新不生效的问题，需要将<code>index.html</code>中的<code>dist/bundle.js</code>转换为<code>localhost:8080/dist/bundle.js</code>这样，相关<a href="http://www.cnblogs.com/llauser/p/6795428.html" target="_blank" rel="external">参考文档</a>。</p>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>代码压缩这个问题就简单得多了，webpack内置了一个<code>UglifyJsPlugin</code>插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        compress: &#123;</div><div class="line">        	warnings: false</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">],</div></pre></td></tr></table></figure></p>
<p>相关的配置参数也请移步<a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin" target="_blank" rel="external">文档</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，简单理清了webpack的使用方法，并简单搭建了一套开发环境。想到之前学习webpack的时候，满世界找教程，都发现教程基本上都是webpack1的攻略，很多配置都“过时”了。这让我明白了一个道理：<strong>官方的文档才是首先应该去翻阅的教程！</strong>在今后的学习中，更应该注意这个问题，至于英语文档啥的这个总是得克服的不是嘛…</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/webpack" class="article_tag">#webpack</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack与gulp"><span class="toc-number">1.1.</span> <span class="toc-text">webpack与gulp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化开发"><span class="toc-number">1.2.</span> <span class="toc-text">模块化开发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用方法"><span class="toc-number">2.</span> <span class="toc-text">使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入口文件"><span class="toc-number">2.1.</span> <span class="toc-text">入口文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader"><span class="toc-number">2.2.</span> <span class="toc-text">loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置文件"><span class="toc-number">2.3.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#路径"><span class="toc-number">2.3.1.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块"><span class="toc-number">2.3.2.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">2.3.3.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插件"><span class="toc-number">2.4.</span> <span class="toc-text">插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搭建开发环境"><span class="toc-number">3.</span> <span class="toc-text">搭建开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css"><span class="toc-number">3.1.</span> <span class="toc-text">css</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript"><span class="toc-number">3.2.</span> <span class="toc-text">javascript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热更新"><span class="toc-number">3.3.</span> <span class="toc-text">热更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码压缩"><span class="toc-number">3.4.</span> <span class="toc-text">代码压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>