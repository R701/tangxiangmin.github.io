<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
            <a class="nav_item" href="/test">Test</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">实现一个简单的Promise</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2017/4/25 22:46:29</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>回调函数在JavaScript中随处可见，在NodeJS中更是家常便饭，随着而来的就是<strong>回调地狱</strong>。尽管早有耳闻，也知道<code>Promise</code>是解决回调地狱的一种方法，却只是简单地了解几个API。最近在看<code>axios</code>的源码，发现拦截器<code>interceptors</code>那里的实现也是基于<code>Promise</code>的，加上阅读《你不知道的JavaScript（中卷）》的时候，书中花了一半的篇幅讲解<code>Promise</code>，然而却一脸懵比。现在 是时候弄清楚<code>Promise</code>的真面目了。</p>
<a id="more"></a>
<p>现在是2017年，网上已经有了大量的关于<code>Promise</code>的文章，本文参考下面文章，结合我自己的理解，实现一个简单的<code>Promise</code>对象和<code>then</code>方法：</p>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" target="_blank" rel="external">JavaScript Promise：简介</a></li>
<li><a href="http://www.cnblogs.com/ygm125/p/3735677.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">教你一步一步实现一个Promise</a></li>
<li><a href="http://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="external">大白话讲解Promise</a></li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先需要明白的是<code>Promise</code>到底是什么东西，上面的文档多多少少提到了一些，还是让我们打开<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN</a>看一看。</p>
<blockquote>
<p>Promise实例是一个代理对象，被代理的值在该实例被创建时可能是未知的（也可能是已知的，但是都将他们看作是未知异步的）。该实例允许我们为异步代码注册相应的成功和失败处理函数，并允许我们像使用同步代码一样使用异步返回值（这正是“代理”的含义，指代了未来的数据值）</p>
</blockquote>
<p>概念总是模糊的，让我们先看看Promise提供的一些接口（现在的浏览器基本上都内置了Promise对象，所以放心大胆的测试吧）。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>下面代码模拟了一次异步的请求，并假设返回一个<code>data</code>数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise((resolve, reject)=&gt;&#123;</div><div class="line">	console.log(&quot;send request...&quot;);</div><div class="line"> 	setTimeout(()=&gt;&#123;</div><div class="line">        var data = &quot;hello&quot;;</div><div class="line">        console.log(&quot;get data &quot; + data);</div><div class="line">        resolve(data);</div><div class="line">    &#125;,1000);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 调用then并&quot;提前&quot;使用data</div><div class="line">p.then((res)=&gt;&#123;</div><div class="line">	console.log(res);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Promise构造函数接受一个函数<code>resolver</code>作为参数，并在构造函数内部会调用这个<code>resolver</code>函数，通常情况下<code>resolver</code>会执行一些异步操作。</p>
<p>我们知道，JavaScript的同步代码是会先于异步代码执行的（不论代码块出现的先后顺序），上面在异步代码setTimeout还并没有执行的时候，对象<code>p</code>已经实例化完成并调用了<code>then</code>方法。</p>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p><code>then</code>方法接收两个参数，第一个参数为前面的<code>resolver</code>异步执行成功对应的回调，第二个参数为异步执行失败对应的回调函数。<br>前面提到，当异步代码还没有执行的时候，我们就注册了对应的处理函数。这是显而易见的，比如<code>$.post(url, postdata, function(res){},&#39;json&#39;)</code>一样，我们也是需要先注册一个使用异步请求返回的数据<code>res</code>作为参数的回调函数。<code>then</code>方法与前面这种注册回调函数的方法并没有什么不同，都需要使用异步数据作为参数。<br>但是！！如果此时需要根据<code>res</code>发起另外一个异步请求的时候，情况就有很大的不同了：</p>
<ul>
<li>在使用回调函数的情形中，需要在回调函数中嵌套异步请求并继续注册回调函数，如果继续嵌套，宾果，回调地狱就这么来了</li>
<li>在<code>Promise</code>的<code>then</code>中如果返回一个新的<code>Promise</code>对象，则就可以继续调用<code>then</code>方法并处理异步数据，继续异步则形成的是链式调用而不是回调嵌套</li>
</ul>
<p>下面是简单的描述代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 回调地狱</div><div class="line">$.post(url1, postdata1, (res1)=&gt;&#123;</div><div class="line">  	// 处理res1并生成postdata2</div><div class="line">  	$.post.(url2, postdata2, (res2)=&gt;&#123;</div><div class="line">      	// 处理res2并生成postdata3...</div><div class="line">      	// $.post...</div><div class="line">  	&#125;, &apos;json&apos;)</div><div class="line">&#125;, &apos;json&apos;);</div><div class="line"></div><div class="line">// Prmise</div><div class="line">var p = new Promise((resolve, reject)=&gt;&#123;</div><div class="line">  	$.post(url, postdata, (res)=&gt;&#123;</div><div class="line">      	resolve(res);</div><div class="line">  	&#125;, &apos;json&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then((res)=&gt;&#123;</div><div class="line">	// 处理res1并生成postdata2</div><div class="line">    console.log(&quot;first get: &quot; + res[&apos;id&apos;]);</div><div class="line">    return new Promise((resolve, reject)=&gt;&#123;</div><div class="line">      	$.post(&apos;1.php&apos;, res, (res)=&gt;&#123;</div><div class="line">      		resolve(res);</div><div class="line">      	&#125;,&apos;json&apos;)</div><div class="line">	&#125;)</div><div class="line">&#125;).then((res2)=&gt;&#123;</div><div class="line">	// 处理res1并生成postdata3</div><div class="line">	console.log(&quot;second get: &quot; + res[&apos;id&apos;]);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>可以看见，相对于嵌套的回调函数，使用<code>then</code>注册的异步处理函数都是“平行的”，也就不存在多重嵌套了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>Promise</code>最需要理解的就是它的构造函数和<code>then</code>方法的实现，下面就让我们一步一步实现一个最基本的Promise对象。<br>从文档中了解到，一个Promise在可能具备三种状态：</p>
<ul>
<li>初始状态<code>pendding</code></li>
<li>异步操作成功状态<code>fulfilled</code></li>
<li>异步操作失败状态<code>rejected</code></li>
</ul>
<p>也就是说，只能能发生下面两种情况中的某一种，异步操作要么成功，要么失败，这是显而易见的：</p>
<ul>
<li><code>pendding</code>到<code>fulfilled</code>，此时执行<code>reslove</code></li>
<li><code>pendding</code>到<code>rejected</code>，此时执行<code>reject</code></li>
</ul>
<h3 id="基本封装"><a href="#基本封装" class="headerlink" title="基本封装"></a>基本封装</h3><p>需要注意的是，在实例化对象的时候，参数只是一个<code>reslover</code>闭包函数名，并没声明具体的<code>reslove</code>或者<code>reject</code>，这意味着我们必须自己在内部实现<code>reslover</code>的调用，然后在调用<code>then</code>方法的时候使用其参数进行。还是看代码吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">const</span> PENDING = <span class="number">0</span>,</div><div class="line">		  FULFILLED = <span class="number">1</span>,</div><div class="line">		  REJECTED = <span class="number">2</span>;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</div><div class="line">		<span class="keyword">constructor</span>(resolver)&#123;</div><div class="line">			<span class="comment">// 维持异步状态</span></div><div class="line">			<span class="keyword">this</span>.status = PENDING;</div><div class="line"></div><div class="line">			<span class="comment">// 保存异步回调函数</span></div><div class="line">			<span class="keyword">this</span>.onfulfilled;</div><div class="line">			<span class="keyword">this</span>.onrejected;</div><div class="line"></div><div class="line">			<span class="comment">// 保存异步操作结果</span></div><div class="line">			<span class="keyword">this</span>.value;</div><div class="line"></div><div class="line">			<span class="comment">// 定义reslove和reject，执行异步操作，并在异步结果完成时手动调用reslove或者reject</span></div><div class="line">			<span class="comment">// reslove和reject在内部</span></div><div class="line">			<span class="comment">// 		1.负责改变当前promise的状态</span></div><div class="line">			<span class="comment">// 		2.调用then方法指定的onfulfilled或onrejected</span></div><div class="line">			resolver(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">				<span class="keyword">this</span>.status = FULFILLED;</div><div class="line">				<span class="keyword">this</span>.onfulfilled(value);</div><div class="line">			&#125;, (value)=&gt;&#123;</div><div class="line">				<span class="keyword">this</span>.status = REJECTED;</div><div class="line">				<span class="keyword">this</span>.onrejected(value);</div><div class="line">			&#125;);</div><div class="line"></div><div class="line">			<span class="comment">// 构造函数返回当前promise对象</span></div><div class="line">			<span class="comment">// 该对象包含value，reason和status属性，并在其then方法中使用这些值</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		then(onfulfilled, onrejected)&#123;</div><div class="line">			<span class="comment">// 由于同步代码会先于异步代码执行，因此在then方法中为promise对象是完全没有问题的</span></div><div class="line">            <span class="comment">// 如果reslover本身就是同步代码，则会立即改变status，因此需要根据status选择执行对应的逻辑</span></div><div class="line">			<span class="keyword">switch</span>(<span class="keyword">this</span>.status)&#123;</div><div class="line">				<span class="keyword">case</span> PENDING:</div><div class="line">					<span class="keyword">this</span>.onfulfilled = onfulfilled;</div><div class="line">					<span class="keyword">this</span>.onrejected = onrejected;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> FULFILLED:</div><div class="line">					onfulfilled(<span class="keyword">this</span>.value);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> REJECTED:</div><div class="line">					onrejected(<span class="keyword">this</span>.reason);</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">window</span>.Promise = <span class="built_in">Promise</span>;</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure></p>
<p>上面的代码去掉注释也没几行了，实际上现在的这个<code>Promise</code>跟常规的回调函数处理异步方式并没有什么区别，除了在<code>then</code>中注册回调函数导致代码看起来更加绕了，别走开，后面才有趣，在此之前先让我们测试一下这个版本<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> data = <span class="string">"hello from future!"</span>;</div><div class="line">        resolve(data);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// "hello from future!"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这里就没有测试<code>reject</code>的情况了，可以看见，仍旧是需要我们手动去触发<code>resolve</code>并通知异步完成。</p>
<h3 id="同步转异步"><a href="#同步转异步" class="headerlink" title="同步转异步"></a>同步转异步</h3><p>上面的代码还存在很多问题，在测试同步代码的时候是会报错的，因为<code>resolve</code>内部调用了<code>this.onfulfilled</code>，如果是同步代码，在执行<code>then</code>方法的时候<code>status</code>已经不是<code>PENDING</code>状态了；<code>Promise</code>有一个核心的思想：“不论是同步代码还是异步代码，都一并视为异步处理”（这句话是在《你不知道的JavaScript(中卷)》看见的）。另外<code>reslove</code>和<code>reject</code>的逻辑基本相似，我们应该整理一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写constructor</span></div><div class="line"><span class="keyword">constructor</span>()&#123;</div><div class="line">	resolver(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">this</span>.updateStatus(FULFILLED, value);</div><div class="line">    &#125;, (reason)=&gt;&#123;</div><div class="line">        <span class="keyword">this</span>.updateStatus(REJECTED, value);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 统一处理状态改变</span></div><div class="line">updateStatus(status, value)&#123;</div><div class="line">    <span class="comment">// resolver只处理成功或者失败</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING)&#123;</div><div class="line">        <span class="comment">// 即使是同步的代码，这里也转换为异步执行，保证then方法是先执行的</span></div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            <span class="keyword">this</span>.status = status;</div><div class="line">            <span class="keyword">this</span>.value = (<span class="keyword">this</span>.status === FULFILLED) ?</div><div class="line">                         (<span class="keyword">this</span>.onfulfilled &amp;&amp; <span class="keyword">this</span>.onfulfilled(value)) :</div><div class="line">                         (<span class="keyword">this</span>.onrejected &amp;&amp; <span class="keyword">this</span>.onrejected(value));</div><div class="line">            <span class="keyword">this</span>.onfulfilled = <span class="keyword">this</span>.onrejected = <span class="literal">null</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在测试同步代码也会成功了，原因就在于<code>updateStatus</code>内部使用一个定时器将同步或异步代码都转换成异步代码执行，保证了<code>then</code>方法的优先调用！</p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>上面的代码保证了在异步代码外部的<code>then</code>方法中注册回调函数，那么，嵌套异步转链式调用是怎么实现的呢？<br>在<code>jQuery</code>中，通过为接口返回<code>this</code>实现链式调用，同理，我们在<code>then</code>方法中返回一个新的<code>Promise</code>实现链式调用，由于<code>then</code>方法接受的是<code>onfulfilled</code>和<code>onrejected</code>，因此这里我们需要自己实现这个返回的<code>promise</code>对象的<code>reslover</code>参数。</p>
<p>需要注意的是，并不是每个<code>onfulfilled</code>都必须返回新的<code>Promise</code>对象，如果异步嵌套结束了，我们就没必要再实例一个<code>Promise</code>了。也就是说，这里需要有一个判断<code>onfulfilled</code>是否返回了<code>Promise</code>对象的方法，常规的做法是使用“鸭子类型”：只要对象具有<code>then</code>方法，那么他就是一个<code>primise</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isThenable = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj[<span class="string">'then'</span>] == <span class="string">'function'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是改进后的<code>then</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">then(onfulfilled, onrejected)&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">        <span class="keyword">let</span> success = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">            <span class="comment">// 这里执行onFulfilled，判断是否是promise对象并将返回结果作为参数传递到当前promise的reslove中</span></div><div class="line">            <span class="comment">// 如果没有返回值，则默认返回原本的value值，这一步的处理并不是必须的</span></div><div class="line">            <span class="keyword">let</span> result = onfulfilled(value) || value;</div><div class="line">            <span class="keyword">if</span> (isThenable(result))&#123;</div><div class="line">                result.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">                    resolve(value);</div><div class="line">                &#125;, (value)=&gt;&#123;</div><div class="line">                    reject(value);</div><div class="line">                &#125;);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                resolve(result);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> error = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">            <span class="keyword">let</span> result = onrejected(value) || value;</div><div class="line">            resolve(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.status)&#123;</div><div class="line">            <span class="keyword">case</span> PENDING:</div><div class="line">            	<span class="comment">// 将原本的onfulfilled和onrejected替换成新的处理函数，并在内部手动调用resolve和reject</span></div><div class="line">                <span class="keyword">this</span>.onfulfilled = success;</div><div class="line">                <span class="keyword">this</span>.onrejected = error;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> FULFILLED:</div><div class="line">                success(<span class="keyword">this</span>.value);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> REJECTED:</div><div class="line">                error(<span class="keyword">this</span>.reason);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>老规矩，先测试一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>)=&gt;</span>&#123;</div><div class="line">    <span class="comment">// 异步测试</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> data = <span class="string">"hello from future!"</span>;</div><div class="line">        res(data);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">    <span class="comment">// 同步测试</span></div><div class="line">    <span class="comment">// var data = "hello from future!";</span></div><div class="line">    <span class="comment">// res(data);</span></div><div class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// hello from future!</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove, reject</span>)=&gt;</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            data += <span class="string">"--No.2"</span>;</div><div class="line">            reslove(data);</div><div class="line">        &#125;, <span class="number">1000</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">//hello from future!--No.2</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>大功告成！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>附上整份源码(绝对没有凑字数的嫌疑)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">const</span> PENDING = <span class="number">0</span>,</div><div class="line">		  FULFILLED = <span class="number">1</span>,</div><div class="line">		  REJECTED = <span class="number">2</span>;</div><div class="line"></div><div class="line">  	<span class="keyword">const</span> isThenable = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj[<span class="string">'then'</span>] == <span class="string">'function'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</div><div class="line">		<span class="keyword">constructor</span>(resolver)&#123;</div><div class="line">			<span class="comment">// 维持异步状态</span></div><div class="line">			<span class="keyword">this</span>.status = PENDING;</div><div class="line"></div><div class="line">			<span class="comment">// 保存异步回调函数</span></div><div class="line">			<span class="keyword">this</span>.onfulfilled;</div><div class="line">			<span class="keyword">this</span>.onrejected;</div><div class="line"></div><div class="line">			<span class="comment">// 保存异步操作结果</span></div><div class="line">			<span class="keyword">this</span>.value;</div><div class="line"></div><div class="line">			<span class="comment">// 定义reslove和reject，执行异步操作，并在异步结果完成时手动调用reslove或者reject</span></div><div class="line">			<span class="comment">// reslove和reject在内部</span></div><div class="line">			<span class="comment">// 		1.负责改变当前promise的状态</span></div><div class="line">			<span class="comment">// 		2.调用then方法指定的onfulfilled或onrejected</span></div><div class="line">			resolver(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">				<span class="keyword">this</span>.updateStatus(FULFILLED, value);</div><div class="line">			&#125;, (reason)=&gt;&#123;</div><div class="line">				<span class="keyword">this</span>.updateStatus(REJECTED, value);</div><div class="line">			&#125;);</div><div class="line"></div><div class="line">			<span class="comment">// 构造函数返回当前promise对象</span></div><div class="line">			<span class="comment">// 该对象包含value，reason和status属性，并在其then方法中使用这些值</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		updateStatus(status, value)&#123;</div><div class="line">			<span class="comment">// resolver只处理成功或者失败</span></div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING)&#123;</div><div class="line">				<span class="comment">// 即使是同步的代码，这里也转换为异步执行，保证then方法是先执行的</span></div><div class="line">				setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">		            <span class="keyword">this</span>.status = status;</div><div class="line">		            <span class="keyword">this</span>.value = (<span class="keyword">this</span>.status === FULFILLED) ? </div><div class="line">		            			(<span class="keyword">this</span>.onfulfilled &amp;&amp; <span class="keyword">this</span>.onfulfilled(value)) : </div><div class="line">		            			(<span class="keyword">this</span>.onrejected &amp;&amp; <span class="keyword">this</span>.onrejected(value));</div><div class="line"></div><div class="line">			       	<span class="keyword">this</span>.onfulfilled = <span class="keyword">this</span>.onrejected = <span class="literal">undefined</span>;</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">		then(onfulfilled, onrejected)&#123;</div><div class="line">			<span class="comment">// 由于同步代码会先于异步代码执行，因此在then方法中为promise对象是完全没有问题的</span></div><div class="line">			<span class="comment">// 如果reslover本身就是同步代码，则会立即改变status，因此需要根据status选择执行对应的逻辑</span></div><div class="line">			<span class="comment">// 每个then方法都返回一个新的promise对象，实现链式调用</span></div><div class="line"></div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line"></div><div class="line">				<span class="keyword">let</span> success = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">					<span class="comment">// 这里执行onFulfilled，判断是否是promise对象并将返回结果作为参数传递到当前promise的reslove中</span></div><div class="line">					<span class="comment">// 如果没有返回值，则默认返回原本的value值，这一步的处理并不是必须的</span></div><div class="line">					<span class="keyword">let</span> result = onfulfilled(value) || value;</div><div class="line">					<span class="keyword">if</span> (isThenable(result))&#123;</div><div class="line">						result.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">	                        resolve(value);</div><div class="line">	                    &#125;, (value)=&gt;&#123;</div><div class="line">	                        reject(value);</div><div class="line">	                    &#125;);</div><div class="line">					&#125;<span class="keyword">else</span> &#123;</div><div class="line">						resolve(result);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">let</span> error = <span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</div><div class="line">					<span class="keyword">let</span> result = onrejected(value) || value;</div><div class="line">					resolve(result);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">switch</span>(<span class="keyword">this</span>.status)&#123;</div><div class="line">					<span class="keyword">case</span> PENDING:</div><div class="line">						<span class="keyword">this</span>.onfulfilled = success;</div><div class="line">						<span class="keyword">this</span>.onrejected = error;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					<span class="keyword">case</span> FULFILLED:</div><div class="line">						success(<span class="keyword">this</span>.value);</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					<span class="keyword">case</span> REJECTED:</div><div class="line">						error(<span class="keyword">this</span>.reason);</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">window</span>.Promise = <span class="built_in">Promise</span>;</div><div class="line"></div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>实现了<code>Promise</code>的构造函数和<code>then</code>方法，整个<code>Promise</code>就掌握了一大部分。除了最基本的使用之外，<code>promise</code>还提供了几个常用的方法：</p>
<ul>
<li><code>all</code>，该方法接受一个promise对象数组，且只有当全部的对象都执行成功之后才会触发成功</li>
<li><code>race</code>，方法接受一个promise对象数组，只要某一个对象执行成功，父promise就会成功</li>
<li><code>reject</code>，调用Promise的rejected句柄，并返回这个Promise对象</li>
<li><code>reslove</code>，用成功值value完成一个Promise对象，这是一个很常用的方法！</li>
</ul>
<p>上面的方法就不一一实现了，本来只是为了实现一个简单的<code>Promise</code>对象而已嘛，这是万万不能用在生产环境中的。写完这98行代码，应该是不用再死记硬背<code>Promise</code>的使用方法了。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/Promise" class="article_tag">#Promise</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-number">1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then"><span class="toc-number">1.2.</span> <span class="toc-text">then</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本封装"><span class="toc-number">2.1.</span> <span class="toc-text">基本封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步转异步"><span class="toc-number">2.2.</span> <span class="toc-text">同步转异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链式调用"><span class="toc-number">2.3.</span> <span class="toc-text">链式调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进阶"><span class="toc-number">3.</span> <span class="toc-text">进阶</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>