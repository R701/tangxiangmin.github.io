<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">DOM编程之节点（一）</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2016/5/28 21:57:21</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>《DOM编程艺术》这本书短小精悍，值得一看，入门必备呀！囫囵吞枣看了两遍，补充了一点笔记，主要是记录了元素节点的相关知识。</p>
<a id="more"></a>
<p>更新于2017-3-6，在阅读了《JavaScript高级程序设计》和《JavaScript权威指南》这两本书后，又回到了这本带领我进入前端大门的《DOM编程艺术》，重新整理关于DOM中元素节点的相关知识，而不仅限于只是这本书的读书笔记啦（所以顺带把标题都改了）。</p>
<h2 id="DOM概念"><a href="#DOM概念" class="headerlink" title="DOM概念"></a>DOM概念</h2><p><code>DOM</code>（Document Object Model），书面语称为文档对象模型，是一套HTML(和XML)文档内容进行抽象和概念化的方法。换句话讲，它提供了一系列的接口，方便我们对文档进行操作。</p>
<p>浏览器负责发起请求并解析HTML文档，然后渲染样式和执行脚本。这都是建立在HTML文档的基础上的，DOM中的<code>D</code>，表示的就是HTML文档。</p>
<p>我们知道，每一个Web浏览器窗口都由一个window对象所表示，而每一个window对象都有一个document属性，引用了<code>Document</code>对象，Document对象的主要功能就是处理网页内容。DOM中的<code>O</code>，表示的就是Document对象。</p>
<p>DOM中的<code>M</code>，是一个抽象的概念，它把整个文档抽象为一棵节点树，文档由节点组成，每个节点都可以通过某条联系找到该页面中的其他任何节点，对整个文档的操作可以具体到对某个节点的操作。具体的文档树这里就不放图了，</p>
<p>尽管节点的类型很多（11种），但最常用的节点是元素节点，每一个元素节点都是一个<code>Element</code>对象，该对象定义了相关的属性和方法，用于操作该节点，某些特定的元素节点还具有特定的属性和方法。</p>
<h2 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h2><p>操作元素节点，首先需要得到该节点的Element对象。</p>
<h3 id="通过document的方法"><a href="#通过document的方法" class="headerlink" title="通过document的方法"></a>通过document的方法</h3><p>首先，document对象提供了一系列的方法用于获取元素节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据id返回单个元素节点</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"id"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 根据标签名或类名返回全部的元素节点列表（是一个HTMLCollection类数组对象，犀牛书上说的是返回Nodelist）</span></div><div class="line"><span class="comment">// 即使只有一个元素节点也必须通过下标访问</span></div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"ul"</span>);</div><div class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">"head"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 根据标签name属性选择元素</span></div><div class="line"><span class="built_in">document</span>.getElementsByName(<span class="string">"tel"</span>);</div></pre></td></tr></table></figure></p>
<p>上面这些获取元素节点的方法都是由document对象提供的，需要注意的是，所有的元素节点都继承了上面的这些方法，因此，可以通过这个方法查找对应元素下的元素节点，缩小查找范围。另外，在CSS3标准化同时新增了一组“选择器API”，用于增强筛选节点的能力<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelector(selector);</div><div class="line"><span class="built_in">document</span>.querySelectorAll(selector);</div></pre></td></tr></table></figure></p>
<p>根据《JavaScript权威指南》的讲解，NodeList类数组对象并不是历史文档的一个静态快照，而是实时的，即文档变化时他们所包含的元素列表能随之改变，但是选择器API所返回的对象并不是事实的，他包含的只是在调用适合选择器所匹配到的元素，但并不更新后续文档的变化（这个不是NodeList和HTMLCollection的区别，而是选择器API自身的特性），下面是测试例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"ul"</span>)[<span class="number">0</span>];</span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> aLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> aLi2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">"li"</span>);</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(aLi); <span class="comment">// HTMLCollection[3]</span></span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(aLi2); <span class="comment">// NodeList[3]</span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></div><div class="line"><span class="undefined">    oUl.appendChild(node);</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(aLi); <span class="comment">// HTMLCollection[4]</span></span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(aLi2); <span class="comment">// NodeList[3]</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="id的另外一种用法"><a href="#id的另外一种用法" class="headerlink" title="id的另外一种用法"></a>id的另外一种用法</h3><p>每个HTML元素都可以有一个id属性，这个id属性在整个文档中必须是唯一的。如果声明的id并没有被window对象使用的话，那么任何有id属性的html元素都会成为window对象的属性（全部变量）。也就是说，可以直接使用id引用对应元素Element对象，这是一个十分酷的使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// html</div><div class="line">&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">// js</div><div class="line">console.log(test); // &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>但是，如果声明了同名的全局变量（不论是在该元素节点之前还是之后进行的声明），就会覆盖掉该元素的引用，因此，使用这种方法存在着潜在的风险。</p>
<h3 id="name的另外一种用法"><a href="#name的另外一种用法" class="headerlink" title="name的另外一种用法"></a>name的另外一种用法</h3><p>HTML的name属性最开始打算为表单元素分配名字的，在表单元素提交到服务器时使用该属性的值。与id类似，如果声明的name值没有被window对象使用，则该元素也会称为window对象的属性。但是与id不同的是：</p>
<ul>
<li>多个元素可以具有相同的name值，此时会组成一个类数组对象（但是如果只有一个则是单一的Element对象而非长度为1的类数组对象，很智能吧）</li>
<li>只有少部分HTML标签的name属性符合这种情况，包括<code>a</code>,<code>iframe</code>,<code>img</code>,<code>form</code>等</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"tel"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(test); <span class="comment">// form</span></div><div class="line"><span class="built_in">console</span>.log(user); <span class="comment">// 报错，input元素的name值不具备这种规则</span></div><div class="line"><span class="built_in">console</span>.log(test.user) <span class="comment">// input，很神奇吧，这就是特殊的元素具有特定的属性和方法，牢记这一点十分重要</span></div></pre></td></tr></table></figure>
<p>这么做的弊端也十分明显，只有少部分标签支持这个特性。而上面所提到的document的方法，是没有这些限制的。此外，为iframe元素指定的name值，表示的是这个子窗口的window对象而不是Element对象。</p>
<h2 id="操作元素节点"><a href="#操作元素节点" class="headerlink" title="操作元素节点"></a>操作元素节点</h2><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>属性节点用来对元素节点做更具体的描述，由于属性节点总是被放在起始标签内部，因此属性节点总是位于元素节点内。获取元素节点上的属性节点十分简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oTest = <span class="built_in">document</span>.querySelector(<span class="string">"#test"</span>);</div><div class="line">oTest.getAttribute(<span class="string">"title"</span>); <span class="comment">//获取title属性的值，若无返回null</span></div></pre></td></tr></table></figure></p>
<p>设置属性节点类似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为titile属性设置hello的值</span></div><div class="line">oTest.setAttribute(<span class="string">"title"</span>,<span class="string">"hello"</span>)</div></pre></td></tr></table></figure></p>
<p>需要注意的是这种方式会覆盖原本的属性值。比如如果需要添加一个类名而不是覆盖类名，需要先将之前的class属性保存起来然后重新赋值。<br>也可以删除某个属性节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oTest.removeAttribute(&quot;title&quot;)</div></pre></td></tr></table></figure></p>
<p>此外如果需要简单判断元素是否含有对应属性，则使用<code>hasAttribute(attr)</code>方法。</p>
<p>HTML5新增了自定义属性，使用<code>data-*</code>进行作为属性名，用于保存我们自定义的属性，同时提供了一个dataset属性用于访问自定义属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-demo</span>=<span class="string">"this is demo"</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 忽略"data-"的前缀，需要注意属性名的大小写问题哦</span></div><div class="line"><span class="built_in">console</span>.log(test.dataset.demo); <span class="comment">//  this is demo</span></div></pre></td></tr></table></figure>
<h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><p>文本节点总是被包含在元素节点的内部（尽管某些元素节点并没有文本节点）。我们通过<code>innerHTML</code>属性操作文本节点，如果为其赋值则表示设置文本内容，如果直接返回则显示该元素节点中的文本内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>Haha <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取文本节点</span></div><div class="line"><span class="keyword">var</span> htm = oTest.innerHTML; <span class="comment">// Haha &lt;a href="#"&gt;link&lt;/a&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 设置文本节点</span></div><div class="line">oTest.innerHTML = <span class="string">"Hello World"</span>;</div></pre></td></tr></table></figure>
<p>该属性会注意会返回或修改对应元素节点下的所有标签代码与文本内容，如果只希望获取纯文本，则使用<code>innerText</code>属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var txt = oTest.innerText; // Haha link</div></pre></td></tr></table></figure></p>
<p>此外还有一个<code>textContent</code>的属性，该属性简单地将所有后代文本节点的内容串联在一起然后返回。在大多数情况下可以与innerText属性互换，但是innerText属性不返回script元素的内容，它忽略多余的空白并试图保留表格格式，而textContent则保留全部的空白和换行等文本格式。</p>
<h3 id="元素节点的遍历"><a href="#元素节点的遍历" class="headerlink" title="元素节点的遍历"></a>元素节点的遍历</h3><p>一旦从文档中选取了某个元素，有时候需要查找文档中与之在结构上相关的元素。我们可以通过文档树来遍历找到对应的元素，幸好Documen对象和Element对象定义了一些相关的属性来遍历文档树</p>
<p><strong>元素的父结点</strong><br><code>parentNode</code>属性返回当前结点的父节点，如果是ducument对象则返回null。<br><code>offsetParent</code>属性返回的是离当前结点最近的有定位的父节点，这对绝对定位的元素十分有用。</p>
<p><strong>元素的子节点</strong><br><code>childNodes</code>属性返回当前结点的全部子节点。该属性只统计他自己的子节点而不计算其子节点的子节点，空格与换行都算是文本节点；此外在不同浏览器下会返回不同的节点总数，可以通过节点的nodeType属性查看其具体属性，其中：</p>
<ul>
<li>1表示元素节点</li>
<li>2表示属性节点</li>
<li>3表示文本节点，</li>
<li>共有12种节点类型，其他节点用的很少。</li>
</ul>
<p>该属性返回的是一个节点列表，那么：</p>
<ul>
<li>可以使用<code>firstChild</code>属性代替<code>childNodes[0]</code></li>
<li>可以使用<code>lastChild</code>属性代替<code>childNodes[length-1]</code>；</li>
</ul>
<p>由于我们更希望得到元素的子元素节点而不是元素的全部子节点，因此一般使用<code>children</code>属性，该属性返回整个子元素节点列表，与之相关的还有一个<code>childElementCount</code>属性表示子元素节点的个数</p>
<ul>
<li>可以使用<code>firstElementChild</code>来表示元素的第一个子元素节点<code>children[0]</code>，</li>
<li>可以使用<code>lastElementChild</code>来表示元素的最后一个子元素节点<code>children[childElementCount-1]</code>，</li>
</ul>
<p>需要注意的是，<code>firstElementChild</code>在标准下获取第一个元素类型的节点，但是非标准的ie不支持，在非标准的ie下<code>firstChild</code>获取到的就是第一个元素节（真是坑啊）。</p>
<p><strong>元素的兄弟节点</strong><br>具有相同的父元素的节点称为兄弟节点，使用<code>nextSibling</code>和<code>previousSibling</code>属性来访问相邻的兄弟节点。<br>同上，我们更希望获得相邻的兄弟元素节点过滤掉其他的节点，因此可以使用<code>和nextElementSibling</code>和<code>和previousSibling</code>来访问相连的兄弟元素节点。</p>
<h2 id="操作CSS样式"><a href="#操作CSS样式" class="headerlink" title="操作CSS样式"></a>操作CSS样式</h2><p>CSS描述页面内容应该如何呈现，一般单独编写在样式表中并在加载HTML文档时由浏览器负责解析，但是某些时候也需要使用JavaScript来动态操作元素的样式，这是通过修改元素节点的<code>style</code>属性来实现的。</p>
<h3 id="设置行内样式"><a href="#设置行内样式" class="headerlink" title="设置行内样式"></a>设置行内样式</h3><p>查询元素的style属性返回的是一个叫做<code>CSSStyleDeclaration</code>对象而不是简单的字符串，该对象包含了元素的样式（用谷歌浏览器测试有373条属性，火狐下有698条~~）。如果我们需要为元素设置样式，则可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// html</div><div class="line">&lt;h1 id=&quot;test&quot;&gt;123&lt;/h1&gt;</div><div class="line"></div><div class="line">// js</div><div class="line">test.style.color = &quot;red&quot;;</div></pre></td></tr></table></figure></p>
<p>打开开发者工具就可以看见，元素上多了一条行内样式（这里需要记住，所有的DOM操作设置的样式都是行内样式，因此其样式权重值非常非常高）。此外，也可以直接通过style对象获取元素的已经声明的行内样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;h1 id=&quot;test&quot; style=&quot;color: green;&quot;&gt;123&lt;/h1&gt;</div><div class="line"></div><div class="line">test.style.color; // green</div></pre></td></tr></table></figure></p>
<p>由于<code>-</code>是JavaScript的元素符，因此，如果所需的CSS属性中包含<code>-</code>连字符，比如<code>font-size</code>等，需要转换成<code>fontSize</code>驼峰形式的才行。</p>
<h3 id="查询渲染样式"><a href="#查询渲染样式" class="headerlink" title="查询渲染样式"></a>查询渲染样式</h3><p>但是，一定要记住，通过这种方式只能获得元素的行内样式，而无法获得样式表和<code>&lt;style&gt;</code>标签中声明的样式。这个原因是：为了显示文档，浏览器必须组合元素的样式属性，包括该元素的所有选择器所匹配到的样式，最终计算出的结果才是用于实际显示元素的样式值，这也被称为”计算属性”。要获得最终的渲染样式，应当使用<code>getComputedStyle</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// css</div><div class="line">h1 &#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// html</div><div class="line">&lt;h1 id=&quot;test&quot;&gt;123&lt;/h1&gt;</div><div class="line"></div><div class="line">//js</div><div class="line">var color = window.getComputedStyle(test).color;</div><div class="line">console.log(test.style.color); // &quot;&quot;</div><div class="line">console.log(color); // rgb(255, 0, 0)</div><div class="line"></div><div class="line">// 低版本的IE下存在着兼容</div><div class="line">// 不过我在IE edge上测试貌似也只支持上面那种形式了</div><div class="line">var color2 = test.currentStyle.color;</div></pre></td></tr></table></figure></p>
<p>计算属性具有下面几个特点：</p>
<ul>
<li>计算属性的值是绝对值，类似于百分比和点之类的相对的单位将全部转换为绝对值，开发者工具提供的<code>Elements</code>面板的<code>Computed</code>选项卡，表示的就是计算属性的结果。</li>
<li>计算样式的属性是只读的，也就是说我们无法通过改变计算属性来改变元素的样式</li>
<li>计算属性不包括符合属性，比如<code>margin</code>会被拆分为<code>marginLeft</code>，<code>marginTop</code>等。</li>
</ul>
<p>因此，我们在需要设置行内样式的使用，使用<code>style</code>对象；而在需要获取元素的渲染样式的时候，使用计算属性<code>getComputedStyle</code>(注意兼容)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj, attr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj)[attr];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然通过style对象能精确地操作元素的样式，但是，频繁地修改元素的单条样式所引起的浏览器渲染重绘代价是十分昂贵的，还需要在JS代码中插入大量的样式字符串。实际上，由于样式表是响应的，因此更通用的做法是通过切换类来达到修改元素样式的目的。</p>
<h3 id="动态设置样式类"><a href="#动态设置样式类" class="headerlink" title="动态设置样式类"></a>动态设置样式类</h3><p>通过切换元素的样式类，设置动态样式需要我们提前定义好相关的样式，这种方式是通过<code>className</code>属性来实现的，className属性代表的是元素的class属性值的一个字符串（因为class是JavaScript中的保留字），我们可以通过设置className来修改元素的所有样式类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;h1 class=&quot;text-red test&quot; id=&quot;test&quot;&gt;123&lt;/h1&gt;</div><div class="line"></div><div class="line">// 相当于getAttribute(&quot;class&quot;)</div><div class="line">console.log(test.className); // text-red test</div><div class="line"></div><div class="line">// 相当于setAttribute(&quot;class&quot;,newClassName)</div><div class="line">test.className = &quot;text-green&quot;;</div></pre></td></tr></table></figure></p>
<p>由于className返回的是一个字符串，如果需要单独修改某个类就，就需要拆字符串了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 移除test类</div><div class="line">test.className = test.className.replace(&quot;test&quot;,&quot;&quot;)</div></pre></td></tr></table></figure></p>
<p>这么做貌似比较麻烦，幸好HTML5为元素节点提供了一个<code>classList</code>的属性，该属性是一个只读的类数组对象（无法被覆盖），包含了该元素节点的单独类名，</p>
<ul>
<li>由于该对象是只读的，需要通过<code>add(classname)</code>和<code>remove(classname)</code>来向元素节点添加和删除类</li>
<li>为了便于切换某个类，该对象提供了<code>toggle(classname)</code>的方法</li>
<li>为了检测元素是否包含类，该对象提供了<code>contains(classname)</code>的方法（跟jquery很相似）</li>
<li>该对象还有一个<code>length</code>属性（类名数量）和<code>value</code>属性（与className相同的全部类名字符串）</li>
</ul>
<h3 id="定时器与动画"><a href="#定时器与动画" class="headerlink" title="定时器与动画"></a>定时器与动画</h3><p>定时器是window全局对象的方法，每隔一段时间就调用指定函数，完成动画效果。比如一个移动的动画，其本质效果是改变元素的定位属性值，因此需要预先设定元素的定位方式。</p>
<p>使用DOM来操作CSS是一个很庞大的概念，这里暂时就了解到这里，关于制作动画等方面，可能需要另外再写一篇了。</p>
<h2 id="构造元素节点"><a href="#构造元素节点" class="headerlink" title="构造元素节点"></a>构造元素节点</h2><p>上面提到了如何查找元素节点，以及在元素节点上进行的一些操作。事实上这是大部分JavaScript函数的工作原理，HTML文档的结构由标记负责创建，JavaScript函数只用来改变某些细节而不是底层的网页结构（这个成本会比较大）。但是，在某些时候动态创建节点也是十分有必要的。</p>
<h3 id="拼接HTML字符串"><a href="#拼接HTML字符串" class="headerlink" title="拼接HTML字符串"></a>拼接HTML字符串</h3><p>我们可以直接向文档中添加标记，让浏览器重新解析文档并生成节点。可以使用的是<code>document.write()</code>方法和<code>node.innerHTML</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 向文档中追加内容</div><div class="line">document.write(&quot;&lt;span&gt;&lt;/span&gt;&quot;);</div><div class="line"></div><div class="line">// 改变test节点的文本节点</div><div class="line">test.innerHTML = &quot;&lt;span&gt;&lt;/span&gt;&quot;;</div><div class="line">// 由于使用innerHTML会替换元素的全部子节点，因此如果只是追加元素，则需要</div><div class="line">var htm = test.innerHTML;</div><div class="line">text.innerHTML = htm + &quot;&lt;span&gt;&lt;/span&gt;&quot;;</div></pre></td></tr></table></figure></p>
<p><code>innerHTML</code>可以向某个具体的元素节点中输入内容；而<code>document.write()</code>可以看作是向<code>&lt;body&gt;</code>标签中输出内容，这里还有一个需要注意的地方：如果文档还没有解析完成，则使用write方法会向文档中追加内容；如果当文档已经解析完成（触发onload事件）后直接调用write方法，会覆盖整个文档！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.onload = function()&#123;</div><div class="line">	 document.write(&quot;&lt;p&gt;clear&lt;/p&gt;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是因为文档解析完毕之后，文档流已经关闭了，这个时候执行write(方法会自动调用<code>document.open()</code>方法来创建一个新的文档流，并写入新的内容，再通过浏览器展现，这样就会覆盖原来的内容<br>且会导致整个浏览器的重绘。即使在文档解析时使用write方法不会覆盖整个文档，也可能影响后续文档的生成，因此这也是为什么浏览器加载，解析和执行<code>&lt;script&gt;</code>标签时会阻塞后续文档解析的一个原因。</p>
<p>另外，使用上述两种方式插入元素节点，需要在JS代码中拼接大量的HTML字符串，这个看起来不是很美观，违背了“行为，样式和结构分离”的知道思想。（然而，作者肯定没想到现在流行的前端框架<code>Vue</code>，<code>React</code>等，貌似又回到了样式结构和行为融合为一体的情形，哈哈）。</p>
<h3 id="生成元素节点"><a href="#生成元素节点" class="headerlink" title="生成元素节点"></a>生成元素节点</h3><p>除了上面通过拼接HTML文档字符串生成节点，我们也可以使用Node对象的方法来创建一个节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建对应标签的元素节点并返回一个ElementNode对象</span></div><div class="line"><span class="built_in">document</span>.createElement(tagname);</div></pre></td></tr></table></figure></p>
<p>然后通过操作这个元素节点，设置其属性节点，添加样式及子元素，就可以构造一个真正的元素节点，就向是我们从DOM树上获取得到的一样。然后只需要通过某种办法将他重新挂到DOM树上就可以了。</p>
<p>除了生成元素节点，还可以生成其他节点，不过使用的比较少。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建内容为text的文本节点</span></div><div class="line"><span class="built_in">document</span>.createTextNode(text);</div><div class="line"></div><div class="line"><span class="comment">// 创建评论节点</span></div><div class="line"><span class="built_in">document</span>.createComment(text);</div></pre></td></tr></table></figure></p>
<p>另外，每个节点还有一个<code>cloneNode()</code>的方法，来返回该节点的一个全新副本，如果向该方法传入true则会递归复制该节点的所有子节点（但是不会复制绑定的事件）。通过克隆节点可以很快速的生成一个相同的节点。</p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>动态创建的节点，保存在内存，需要将创建的节点插入到节点树中才会渲染出来。将节点插入DOM树，首先需要确定插入点，这里可以根据父节点确定，也可以通过兄弟节点确定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将动态创建的节点插入到父节点中</span></div><div class="line">parent.appendChild(node);</div><div class="line"></div><div class="line"><span class="comment">// 将动态创建的节点插入到兄弟节点前，注意这个方法也是在父节点上进行的</span></div><div class="line">parentUl.insertBefore(oLi, siblingLi);</div></pre></td></tr></table></figure></p>
<p>但是需要注意的是并没有insertAfter方法（尽管这个需求十分常见），需要自定义一个。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAfter</span>(<span class="params">parent, sibling, node</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> children = parent.children;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (children[children.length - <span class="number">1</span>] == sibling)&#123;</div><div class="line">        parent.appendChild(node);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> next = sibling.nextElementSibling;</div><div class="line">        <span class="built_in">console</span>.log(next);</div><div class="line">        parent.insertBefore(node, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HTML5引进了一个十分强大的插入节点的API，叫做<code>innerAdjacentHTML()</code>，该方法接收两个参数：</p>
<ul>
<li>第一个参数是”beforebegin”（起始标签前，即作为当前结点前一个兄弟插入）,”afterbegin”（起始标签后，即作为当前结点的第一个子元素插入）,”beforeend”（闭合标签前，即作为当前结点的最后一个元素插入）,”afterend”（闭合标签后，即作为当前结点后一个兄弟插入）</li>
<li>第二个参数是一个HTML文档字符串。用于生成的节点。</li>
</ul>
<p>可以很方便地使用这个方法插入节点，只需要找到参考节点，再根据该节点传入对应的插入位置就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">siblingLi.insertAdjacentHTML(&quot;afterEnd&quot;,&quot;&lt;li&gt;hell&lt;/li&gt;&quot;);</div></pre></td></tr></table></figure></p>
<p>对于非闭合标签（如<code>img</code>等标签）来说，使用<code>afterbegin</code>和<code>beforeend</code>的参数可能会无法显示插入的节点，浏览器会尝试将非闭合标签转变成闭合标签，然后将元素正确插入，然而，一个使用<code>&lt;img&gt;&lt;/img&gt;</code>包围的元素是无效的HTML文档，浏览器并不会正常解析（这个是我根据测试情况猜的~）</p>
<h3 id="删除和替换子节点"><a href="#删除和替换子节点" class="headerlink" title="删除和替换子节点"></a>删除和替换子节点</h3><p>如果需要删除元素的子节点，除了暴力使用innerHTML进行覆盖之外，也可以调用<code>removeChild</code>方法来删除某个子节点；如果需要使用另外一个元素节点替换该节点（所谓替换就是移除旧节点然后在原来的位置插入新节点），可以使用<code>replaceNode</code>方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除子节点</span></div><div class="line">parentUl.removeChild(siblingLi)</div><div class="line"></div><div class="line"><span class="comment">// 使用oLi新节点替换子节点</span></div><div class="line"> parentUl.replaceChild(oLi, siblingLi)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这本书，我仍旧有一些疑惑：我所理解的W3C标准就是“结构，表现，行为三者分离”，但是随着逐步深入，发现HTML,CSS,DOM之间都有互相叠加的区域，可以在HTML中设置样式与事件响应，可以在CSS中通过伪类达成动态交互，可以在DOM中创建节点及设置样式，三者并不冲突，而具体使用则需要仔细斟酌。随着CSS3和HTML5的深入，发现这三者越来越融合的感觉，至于具体的方面，还需要进一步的学习才行。</p>
<p>更新于2017-3-8<br>《DOM编程艺术》这本书是16年五月份看的，距今已经大半年了，这本书给我的印象是循序渐进，结构合理，对于当时刚想进入前端大门的来说真是太友好了。书中不仅介绍了关于DOM的知识，还介绍了“平稳退化与渐进增强”以及“性能优化”等方面的东西，在后面的工作中，才发现这些建议真的是太重要了，尽管我现在对于兼容性的处理还是菜的不行。<br>这次笔记的更新，主要是重新整理了关于元素节点操作的知识，至于事件和Ajax等方面的知识，也需要重新学习整理才行。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/读书笔记" class="article_tag">#读书笔记</a>
        
        <a href="/tags/DOM" class="article_tag">#DOM</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM概念"><span class="toc-number">1.</span> <span class="toc-text">DOM概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取元素节点"><span class="toc-number">2.</span> <span class="toc-text">获取元素节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过document的方法"><span class="toc-number">2.1.</span> <span class="toc-text">通过document的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id的另外一种用法"><span class="toc-number">2.2.</span> <span class="toc-text">id的另外一种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#name的另外一种用法"><span class="toc-number">2.3.</span> <span class="toc-text">name的另外一种用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作元素节点"><span class="toc-number">3.</span> <span class="toc-text">操作元素节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性节点"><span class="toc-number">3.1.</span> <span class="toc-text">属性节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本节点"><span class="toc-number">3.2.</span> <span class="toc-text">文本节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素节点的遍历"><span class="toc-number">3.3.</span> <span class="toc-text">元素节点的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作CSS样式"><span class="toc-number">4.</span> <span class="toc-text">操作CSS样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置行内样式"><span class="toc-number">4.1.</span> <span class="toc-text">设置行内样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询渲染样式"><span class="toc-number">4.2.</span> <span class="toc-text">查询渲染样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态设置样式类"><span class="toc-number">4.3.</span> <span class="toc-text">动态设置样式类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器与动画"><span class="toc-number">4.4.</span> <span class="toc-text">定时器与动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造元素节点"><span class="toc-number">5.</span> <span class="toc-text">构造元素节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接HTML字符串"><span class="toc-number">5.1.</span> <span class="toc-text">拼接HTML字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成元素节点"><span class="toc-number">5.2.</span> <span class="toc-text">生成元素节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入节点"><span class="toc-number">5.3.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除和替换子节点"><span class="toc-number">5.4.</span> <span class="toc-text">删除和替换子节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>