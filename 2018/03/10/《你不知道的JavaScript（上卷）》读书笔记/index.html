<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="/css/blog.css">
    <link rel="stylesheet" href="/css/fonts/iconfont.css">
    <!--<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">-->
    <link rel="stylesheet" href="//cdn.bootcss.com/fancybox/3.1.25/jquery.fancybox.min.css">
    <script src="/js/require.js" data-main="/js/main"></script>
</head>
<body>
<div id="blog" class="page page-theme-base" v-cloak>
    <blog-header></blog-header>
    <header class="page_hd" data-v-04342fbc="">
    <div class="container header" data-v-04342fbc="">
        <h1 class="logo" data-v-04342fbc="">
            <a href="/" class="nuxt-link-exact-active nuxt-link-active" data-v-04342fbc="">橙红年代</a>
        </h1>
        <div class="show-md" data-v-04342fbc="">
            <div class="btn-list" data-v-04342fbc="">
                <div class="btn-icon" data-v-04342fbc="">
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                    <span class="btn-line" data-v-04342fbc=""></span>
                </div>
            </div>
        </div>
        <nav class="nav-responsive" data-v-04342fbc="">
            
            <a class="nav_item" href="/">首页</a>
            
            <a class="nav_item" href="/archives">归档</a>
            
            <a class="nav_item" href="/tags">标签</a>
            
        </nav>
    </div>
</header>
    <main class="page_mn" >
        <div class="container">
            <article class="article article-detail">
    <header class="text-center">
        <h2 class="article_hd">《你不知道的JavaScript（上卷）》读书笔记</h2>
        <div class="article_info">
            <span class="hide-sm">发表于</span>
            <span class="show-sm">
                <i class="iconfont icon-archives"></i>
            </span>
            <time>2018/3/10 21:01:47</time>
            |
            <span class="hide-sm">分类于</span>
            <span class="show-sm"><i class="iconfont icon-tag"></i></span>
            
                <a href="/categories/JavaScript" class="hover-highlight">JavaScript</a>
            

        </div>
    </header>
    <div class="article_ct">
        <p>《你不知道的JavaScript》大概是去年这个时候看的，上卷主要讲解<strong>作用域和闭包、this和对象原型</strong>这两个部分，阅读之后有很大收获，相当于对于JavaScript这门语言有了新的认识。</p>
<p>最近在复习JavaScript，决定重新阅读，并补充之前遗漏的读书笔记。</p>
<a id="more"></a>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="作用域的概念"><a href="#作用域的概念" class="headerlink" title="作用域的概念"></a>作用域的概念</h3><blockquote>
<p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。</p>
</blockquote>
<p>从下面这行代码开始</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。换句话说，变量的赋值操作会执行两个操作</p>
<ul>
<li>首先编译器会在当前作用域中声明一个变量</li>
<li>然后在运行时引擎会在作用域中<strong>查找</strong>该变量，如果能找到则对齐进行复制</li>
</ul>
<p>引擎执行的查找有两种形式：<code>LHS</code>和<code>RHS</code></p>
<ul>
<li>当变量出现在赋值操作的左侧时进行LHS查询（即查找的目的是为变量进行赋值），如<code>a=2</code></li>
<li>当变量作为赋值操作的源头时进行RHS查找（即查找的目的是获取变量的值），如<code>console.log(a)</code></li>
</ul>
<p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，知道找到该变量或者抵达全局作用域为止。</p>
<p>对于<code>LHS</code>和<code>RHS</code>，上面的查找过程均适用，他们的区别在于当变量还没有声明时（即查询在所有嵌套的作用域中都找不到所需的变量），这两种查找的行为是不一样的</p>
<ul>
<li>如果<code>RHS</code>，则引擎会抛出<code>ReferenceError</code>的错误</li>
<li>如果<code>LHS</code>，<ul>
<li>非严格模式下，全局作用域会创建一个具有该名称的变量，并将其返回给引擎</li>
<li>严格模式下会抛出<code>ReferenceError</code>错误</li>
</ul>
</li>
</ul>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域可分为<strong>词法作用域</strong>和动态作用域，</p>
<ul>
<li>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变（大部分情况下是这样的）。</li>
<li>动态作用域在程序运行时确定变量的值，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</li>
</ul>
<p>JavaScript采用的是词法作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a, b, c)</div><div class="line">    &#125;</div><div class="line">    bar(b * <span class="number">3</span>)</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>上面代码存在3个作用域：</p>
<ul>
<li>全局作用域，其中包含foo一个标识符</li>
<li>包含着foo函数所创建的作用域，其中有a,b,bar三个标识符</li>
<li>包含着bar函数所创建的作用域，其中包含c一个标识符</li>
</ul>
<p>作用域查找会在找到第一个匹配的标识符停止，内部作用域的标识符<strong>遮蔽</strong>了外部作用域的标识符。</p>
<p>词法作用域只会查找一级标识符，也就是说，如果查找<code>foo.bar.baz</code>，词法作用域只会视图查找foo标识符，找到这个变量以后，对象属性访问规则则会分别接管对bar和baz属性的访问。</p>
<p><strong>无论函数在哪里被调用，也无论它何时被调用，它的词法作用域都只由函数被声明时所处的位置决定。</strong></p>
<p>在JavaScript中可以通过<code>with</code>和<code>eval</code>等方式欺骗词法，在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。</p>
<p>但是由于JavaScript引擎会在编译阶段对作用域查找进行性能优化，如果使用上述手段欺骗作用域，则可能导致程序运行效率的下降，因此不建议使用。</p>
<h3 id="函数作用域与块作用域"><a href="#函数作用域与块作用域" class="headerlink" title="函数作用域与块作用域"></a>函数作用域与块作用域</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用）。</p>
<p>通过函数作用域，可以隐藏内部的实现，最小限度地暴露接口的细节。在ES5及之前的版本，JS中只支持函数作用域。</p>
<p>ES6改变了现状，引入了<code>let</code>关键字，它为其声明的变量隐式地附加到所在的块作用域。块级作用域有以下几个技巧</p>
<ul>
<li>由于闭包函数的存在，引擎可能会保存父级作用域中的大数据（即使闭包函数没有使用这个变量），使用块级作用域可以消除这种顾虑</li>
<li>在for循环中，let实际上将计数器重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值<strong>重新进行赋值</strong></li>
</ul>
<p>此外<code>const</code>关键字也可以用来创建块级作用域，区别在于其声明的变量值是固定的，之后任何试图修改值的操作都会引起错误。</p>
<p>需要注意的是<code>let</code>和<code>const</code>声明的变量都不会进行声明提升，这是非常有趣的一点。</p>
<p>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开 发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。</p>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>包含变量和函数在内的所有声明都会在任何代码执行前首先被处理。下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a <span class="comment">// 定义声明在编译阶段进行</span></div><div class="line">a = <span class="number">2</span> <span class="comment">// 赋值声明会被留在原地，等待执行阶段</span></div></pre></td></tr></table></figure>
<p>这个过程就好像变量和函数声明从他们在代码中出现的位置被<strong>移动</strong>到了最上面，这个过程被称为<strong>提升</strong>。</p>
<p>每个作用域都会进行提升操作。需要注意的下面几点</p>
<p><strong>函数声明会提升，但函数表达式不会</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常执行</span></div><div class="line">foo()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 报 TypeError 错误</span></div><div class="line">bar()</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//...&#125;</span></div></pre></td></tr></table></figure>
<p><strong>函数声明提升优先级大于变量声明提升</strong></p>
<p>函数声明和变量声明都会被提升，但是是函数会首先被提升，然后才是变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">foo() <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<strong>先提升</strong>的含义，相当于函数声明提升会<strong>覆盖</strong>同名的变量声明提升。</p>
<p>如果存在多个提升，则后提升的函数声明会覆盖先提升的函数声明，变量亦然。建议不要在同一个作用域中进行重复声明</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。换句话说，闭包使得函数可以继续访问定义时的 词法作用域。</p>
</blockquote>
<p>闭包函数对于其内部的变量查找遵循词法作用域的查找规则（即该闭包函数被声明时所处的位置决定），即使当闭包在其定义的词法作用域以外的地方执行时（比如闭包作为函数的返回值，或者闭包以函数参数的形式传入），这个查找规则也是生效的。</p>
<p>正常情况下当函数执行完毕，函数的整个内部作用域都被销毁，垃圾回收机制会回收不被使用的内存空间。</p>
<p>但是如果在函数执行时产生了闭包，情况就有所不同了。即使定义闭包的函数已经执行完毕，由于闭包仍旧保持对其词法作用域的引用，因此只要闭包在其他地方调用，都可以观察到闭包（即访问定义时的外部变量），下面列举了常见的三种形式</p>
<p><strong>以函数返回值形式调用闭包</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(b)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bar </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> baz = foo(<span class="number">2</span>) <span class="comment">// 以函数返回值的形式调用闭包</span></div><div class="line">baz()</div></pre></td></tr></table></figure>
<p><strong>以回调函数形式调用闭包</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="number">4</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(b)</div><div class="line">    &#125;</div><div class="line">    fn(bar)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">    fn()</div><div class="line">&#125;</div><div class="line">foo(baz)</div></pre></td></tr></table></figure>
<p><strong>以外部变量形式调用闭包</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baz</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(b)</div><div class="line">    &#125;</div><div class="line">    baz = bar</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>)</div><div class="line">baz()</div></pre></td></tr></table></figure>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。JavaScript中的回调函数，实际上就是闭包。</p>
<h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>下面是一个比较常见的面试题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;, i*<span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码本意是每隔100ms输出不同的i值，最后的输出结果却是5个相同的值：5。</p>
<p>如果从JavaScript事件队列的机制来解释，即先执行同步代码，再执行异步代码，定时器生效时访问到的<code>i</code>变量的值已经变成了5，因此最后输出的都是5。</p>
<p>但是究竟是什么导致代码的行为与语义上所暗示的不一样呢？因为我们试图假设循环中每个迭代在运行时都会给自己“捕获”一个<code>i</code>的副本，但根据作用域的原理，<code>i</code>变量会进行声明提升，因此实际上只有一个<code>i</code>，且被封闭在与<code>for</code>同级的全局作用域中。这样，即使定时器使用了5个闭包函数，他们共享的是同一个<code>i</code>变量，所以最后输出的值相同。</p>
<p>换句话说，要解决上面的问题，我们需要在每次循环中都生成一个新的闭包作用域，然后在作用域中保存每次循环不同的<code>i</code>值，这样保证每个闭包访问到不同的变量。</p>
<p>可以使用下面几种方式</p>
<p><strong>通过IIFE来创建新的作用域</strong></p>
<p>因为变量提升只会在提升到当前作用域的顶部，因此可以使用一个变量来保存每次循环中的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> j = i</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(j)</div><div class="line">        &#125;, j * <span class="number">100</span>);</div><div class="line">    &#125;)()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以换成下面这种简写方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(i)</div><div class="line">        &#125;, i * <span class="number">100</span>);</div><div class="line">    &#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>通过let在每次循环时重新声明i</strong></p>
<p>既然上面的问题是由于变量声明提升导致共享一个变量导致的，使用<code>let</code>在<strong>块级作用域</strong>中保存每次循环的值更加简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;, i*<span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>块级作用域和闭包联手可以解决很多问题哦！！</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>通过函数作用域封装内部变量和数据，然后通过闭包暴露相关接口，闭包可以访问内部变量，而其他地方无法访问，这样就可以<strong>封装模块</strong></p>
<p>模块有两个主要特征：</p>
<ul>
<li>为创建内部作用域而调用了一个包装函数；</li>
<li>包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包</li>
</ul>
<p>通过闭包，访问私有变量，封装模块，这是闭包很常用的使用场景。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>显式传递上下文对象参数会让代码变得混乱，而让函数自动引用合适的上下文对象就变得十分重要。</p>
<p><code>this</code>是一个很特别的关键字，它被自动定义在所有函数的作用域中。this是在运行时绑定的，而不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。换句话说，this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>
<p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域</p>
<p>第二步就是寻找函数的调用位置，主要是分析调用栈（就是为了到达当前执行位置所调用的所有函数）</p>
<p>第三步就是了解在函数执行过程中调用位置决定this的绑定对象</p>
<h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><p>如果是是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 默认绑定，无法应用其他规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">// 100</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span></div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<p>默认规则下，</p>
<ul>
<li>非严格模式中，this指向全局对象</li>
<li>严格模式下，this为<code>undefined</code></li>
</ul>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo() <span class="comment">// 1，foo作为对象的方法调用</span></div></pre></td></tr></table></figure>
<p>比较常见问题是被隐式绑定的函数丢失其绑定对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = obj.foo()</div><div class="line">bar() <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>将对象的方法通过函数表达式赋值，然后以普通函数的形式调用时，函数就会丢失其绑定对象</p>
<p>上面这种函数表达式的形式还很明显，在某些使用回调函数的情形下，容易忽略这个问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setTimeout(obj.foo, <span class="number">1000</span>) <span class="comment">// 回调函数已经丢失了其绑定对象，这里是obj</span></div></pre></td></tr></table></figure>
<p>在jQuery中的事件注册中，会在其内部实现中将传入的事件处理函数绑定到当前DOM节点上，需要理解其中的区别。</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，可以使用函数的<code>call</code>和<code>apply</code>两个方法来实现。</p>
<p>这两个方法接受的第一个参数是一个对象，他们会把这个对象绑定到this，然后在函数调用时指定这个this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.call(obj) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>call和apply的区别在于他们处理函数参数的形式</p>
<ul>
<li>call第二个参数及后面多余的参数，当做函数的参数列表</li>
<li>apply第二个参数接受一个数组，当做函数的参数列表</li>
</ul>
<p><strong>硬绑定</strong></p>
<p>硬绑定可以解决函数的this绑定对象丢失的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    foo.call(obj)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论<code>bar</code>以何种形式调用，都不可能改变foo显式绑定this的对象。</p>
<p>硬绑定是一种十分常用的模式，ES5提供了<code>Function.prototype.bind</code>方法，该方法返回一个硬编码的新函数，他会把参数设置为this的上下文，并调用原始函数。</p>
<p><strong>忽略this</strong></p>
<p>如果将null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>
<h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><blockquote>
<p>JavaScript中的new机制实际上和面向类的语言完全不同。实际上并不存在所谓的“构造函数”，只有对函数的“构造调用”</p>
</blockquote>
<p>先来看看这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a <span class="comment">// 现在研究的是这里的this指向</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo(<span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会构造一个新对象并把他绑定到foo调用中的this上，这种绑定被称为<strong>new 绑定</strong>。</p>
<h3 id="四种规则的优先级"><a href="#四种规则的优先级" class="headerlink" title="四种规则的优先级"></a>四种规则的优先级</h3><p>为了判断函数中的this，我们需要做的就是找到函数的调用位置并判断应当应用哪条规则。</p>
<p>首先，默认规则的优先级最低。接下来了解剩下三种规则的比较</p>
<p><strong>1.显示绑定优先级大于隐式绑定</strong></p>
<p>可以用下面代码简单检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    a: <span class="number">100</span></div><div class="line">&#125;</div><div class="line">obj.foo.call(obj2) <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p><strong>2.new绑定优先级大于显式绑定</strong></p>
<p>先来看看这段代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="comment">// console.log(this.a)</span></div><div class="line">    <span class="keyword">this</span>.a = a</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj) <span class="comment">// bar函数的this硬绑定到obj上</span></div><div class="line">bar(<span class="number">2</span>) <span class="comment">// 修改obj.a = 2</span></div><div class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>) <span class="comment">// 对函数的构造调用，返回新对象baz.a = 3</span></div><div class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 2，并没有修改obj.a的值</span></div><div class="line"><span class="built_in">console</span>.log(baz.a) <span class="comment">// 3，//新对象的属性值</span></div></pre></td></tr></table></figure>
<p>可以看见new绑定的优先级高于显式绑定</p>
<p><strong>总结</strong></p>
<p>现在可以根据下面的规则进行this的判断了</p>
<ol>
<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 <code>var bar = new foo()</code></li>
<li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 <code>var bar = foo.call(obj2)</code></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 <code>var bar = obj1.foo()</code></li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。<code>var bar = foo()</code></li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6新增了一种无法使用上述规则的特殊函数类型：箭头函数</p>
<p>箭头函数的this会捕获调用其父函数的this（全局作用域下就是全局对象），箭头函数的绑定无法被修改，(包括new绑定也不行)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(self.a)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以理解为，箭头函数用更常见的词法作用域取代了传统的this机制。</p>
<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象可以通过声明形式和构造形式进行定义。</p>
<p>有一种常见的错误说法是“JavaScript 中万物皆是对象”，这显然是错误的。简单基本类型本身并不是对象。</p>
<p>基本类型的字面量是一个不可变的值，如果要在这个字面上上执行一些操作，比如获取长度、方位其中某个字符等，语言会自动把其转换成一个<strong>包装对象</strong>。</p>
<p>访问对象的属性可以使用<code>.</code>操作符（属性访问）或<code>[]</code>操作符（键访问）</p>
<ul>
<li>属性访问要求属性名满足标识符的命名规范</li>
<li>键访问可以接受任意<code>utf-8/Unicode</code>字符串作为属性名，可以传入动态获取对象属性</li>
</ul>
<p>在JavaScript中，函数也是对象，因此，从技术角度上来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。最保险的说法可能是，“函数”和”方法“在JavaScript中是可以互换的。</p>
<p>ES6定义了<code>Object.assign</code>方法来实现浅复制。</p>
<h3 id="对象描述符"><a href="#对象描述符" class="headerlink" title="对象描述符"></a>对象描述符</h3><p>对象属性的特性可以通过属性描述符来控制</p>
<p><strong>属性描述符</strong></p>
<p>之前学习Vue的时候整理过属性描述符的相关知识：<a href="http://www.shymean.com/article/%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE" target="_blank" rel="external">对象描述符与响应式数据</a>，这里再简单过一遍。</p>
<p>通过<code>Object.getOwnPropertyDescriptor</code>可以获取对象的某个属性描述符，描述符看起来很像是某个对象的属性。</p>
<ul>
<li><code>value</code>，<strong>数据描述符</strong>，用来指代这个属性所包含的数据值的</li>
<li><code>configurable</code>，决定是否可以修改对象某个属性的描述符</li>
<li><code>enumerable</code>，决定某个属性是否在遍历中出现</li>
<li><p><code>writeable</code>，决定是否可以修改属性的值，即是否允许对该属性进行赋值</p>
<p>我们还可以使用<code>defineProperty</code>来修改某个属性的描述符。</p>
</li>
</ul>
<p><strong>访问描述符</strong></p>
<p>语言规范中，对象属性访问的实现实际上是<code>[[get]]</code>，该操作有点类似于函数调用，即首先在对象中根据指定的表示式或字符串常量查找对应的同名属性，如果找到就返回该属性值，如果不存在则会在原型链上实现委托查询（这个后面马上会详细讲解）。</p>
<p>既然属性访问实际上是通过<code>[[get]]</code>实现的，那么肯定存在对属性进行赋值的操作<code>[[put]]</code>。实际上，<code>[[put]]</code>操作的触发并不仅仅是对属性进行赋值这么简单，而是取决于许多因素：</p>
<ul>
<li>属性的<code>writable</code>是否为<code>true</code></li>
<li>属性是否是访问描述符（接下来就会提到）</li>
<li>如果都不会，则会将该值设置为该属性的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    _a: <span class="number">100</span>,</div><div class="line">    get a()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a</div><div class="line">    &#125;,</div><div class="line">    set a(num)&#123;</div><div class="line">        <span class="keyword">this</span>._a = num * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 100</span></div><div class="line">obj.a = <span class="number">200</span></div><div class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 400</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>当为某个属性（这里是<code>msg</code>）定义一个<code>getter</code>或<code>setter</code>时（或两者都存在），该属性就会被定义为<strong>访问描述符</strong>。</p>
<p>对于访问描述符而言，JavaScript会忽略他们的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>一个类就是一张蓝图。为了获得真正可以交互的对象，我们必须按照类来建造（也可以说 实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用 方法并访问其所有公有数据属性。</p>
<p> 实例对象就是类中描述的所有特性的一份副本。类意味着复制。</p>
<p><strong>继承</strong></p>
<p>定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会 包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p>
<p><strong>多态</strong></p>
<p>任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。这个技术被称为多态。</p>
<p>多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。</p>
<p><strong>JavaScript中的类</strong></p>
<p>事实上JavaScript中只有对象，并不存在可以被实例化的”类“，一个对象并不会被复制到其他对象，他们会被<strong>关联起来</strong>。</p>
<p>在JavaScript中模拟类是得不尝试的，可能会埋下更多的隐患。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript中的对象有一个特殊的<code>[[Prototype]]</code>内置属性，其实就是对于其他对象的引用</p>
<p>对于默认的<code>[[get]]</code>操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的<code>[[Prototype]]</code>引用的对象B。</p>
<p>如果在对象B上也无法找到对应的属性，就会继续访问对象B的的<code>[[Prototype]]</code>引用的对象C，如此持续直到找到匹配的属性名（返回对应的属性值）或者查找完整条<code>[[Prototype]]</code>链（返回undefined）。</p>
<p><strong>属性的设置和屏蔽</strong></p>
<p>在于原型链上层时<code>myObject.foo = &quot;bar&quot;</code>会出现的三种情况。</p>
<ol>
<li>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性，并且没 有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。 </li>
<li>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会 调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这 个 setter。</li>
</ol>
<p>换句话说，并不是只要赋值就会在当前对象上添加属性并屏蔽原型链上的属性（只有上面第一种情形会出现）</p>
<p><strong>构造函数的本质</strong></p>
<p>JavaScript中的所有函数默认都会拥有一个名为<code>prototype</code>的属性，他会指向另外一个对象。</p>
<p>通过对函数Foo进行构造调用时（<code>new</code>调用），会创建一个新的对象，并将该对象内部的<code>[[prototype]]</code>连接，关联到<code>Foo.prototype</code>指向的那个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.prototype.constructor = Foo</div></pre></td></tr></table></figure>
<p>可以通过在<code>Foo.prototype</code>上添加公共的属性和方法，然后实例对象都可以访问这些属性和方法了。（我们可以直接将<code>Foo.prototype</code>修改为另外一个对象，这样就会丢失<code>constructor</code>方法）</p>
<p>但是需要注意的是，在JavaScript中，我们并不会将一个对象（”类“）复制到另一个对象（”实例“），而只是将新对象与函数的原型对象关联起来。这个机制被称为<strong>原型继承</strong>。</p>
<blockquote>
<p>”继承“这个词语难免让人疑惑，因为继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两 个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p>
</blockquote>
<p> <strong>委托</strong>这个术语可以更加准确地描述 JavaScript 中对象的关联机制。 </p>
<p>再次强调， JavaScript 中的继承机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a>文档</p>
<blockquote>
<p><strong>Object.create()</strong>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。 </p>
</blockquote>
<p>也就是说，通过<code>create</code>接口，我们可以关联某个对象的<code>[[prototype]]</code>到另一个对象上，从而在执行<code>[[get]]</code>时<strong>委托</strong>原型对象进行查询。</p>
<p>现在我们知道了，<code>[[Prototype]]</code>机制就是存在于对象中的一个内部链接，它会引用其他对象。 </p>
<p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就 会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。</p>
<p>这一系列对象的链接被称为<strong>原型链</strong>。原型链的本质也就是对象之间的关联关系。</p>
<p>委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一 个对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这本书剖析了JavaScript中几个最重要的基础问题：作用域、闭包、this指向和原型链。</p>
<p>周末两天时间重新阅读了这本书，对其中不少知识点有了更深刻的认识，不单单是为了面试和刷题，对于写JavaScript代码也是极有好处的哈哈。</p>

    </div>
    <footer class="article_ft">
        
        <a href="/tags/读书笔记" class="article_tag">#读书笔记</a>
        
        <a href="/tags/原型" class="article_tag">#原型</a>
        
        <a href="/tags/闭包" class="article_tag">#闭包</a>
        
    </footer>

    <div class="article_nav"><a href="/article/mockjs使用心得" class="hover-highlight article_prev">mockjs使用心得</a><a
                href="/article/博客SSR实践总结" class="hover-highlight article_next">博客SSR实践总结</a></div>
</article>
        </div>
    </main>

    <aside>
    <div class="page_sd hide-md">
        <div class="tab">
            <!---->
            
            <ul class="tab_nav">
                <li class="tab_item active" data-target="#J_toc">
                    文章目录
                </li>
                <li class="tab_item" data-target="#J_profile">
                    站点资料
                </li>
            </ul>
            <div class="tab_panel active" id="J_toc">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域"><span class="toc-number">1.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域的概念"><span class="toc-number">1.1.</span> <span class="toc-text">作用域的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词法作用域"><span class="toc-number">1.2.</span> <span class="toc-text">词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域与块作用域"><span class="toc-number">1.3.</span> <span class="toc-text">函数作用域与块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提升"><span class="toc-number">1.4.</span> <span class="toc-text">提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">2.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域闭包"><span class="toc-number">2.1.</span> <span class="toc-text">作用域闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环和闭包"><span class="toc-number">2.2.</span> <span class="toc-text">循环和闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的应用"><span class="toc-number">2.3.</span> <span class="toc-text">闭包的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">3.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认规则"><span class="toc-number">3.1.</span> <span class="toc-text">默认规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式绑定"><span class="toc-number">3.2.</span> <span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#显式绑定"><span class="toc-number">3.3.</span> <span class="toc-text">显式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-绑定"><span class="toc-number">3.4.</span> <span class="toc-text">new 绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四种规则的优先级"><span class="toc-number">3.5.</span> <span class="toc-text">四种规则的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数"><span class="toc-number">3.6.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型与原型链"><span class="toc-number">4.</span> <span class="toc-text">原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">4.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象描述符"><span class="toc-number">4.2.</span> <span class="toc-text">对象描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-number">4.3.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型"><span class="toc-number">4.4.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-number">4.5.</span> <span class="toc-text">原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol>
            </div>
            
            <div class="tab_panel " id="J_profile">
                <div>
                    <div class="me">
                        <img src="http://shymean.com/_nuxt/img/head.dd612ee.jpg" alt="shymean" width="100" height="100">
                        <h3>shymean</h3>
                        <p>一个不学无术且无趣的人。</p>
                    </div>
                    <div class="nav-border">
                        <a href="/book" class="nav_item">
                            <i class="iconfont icon-bookshelf"></i>
                            <br>书架
                        </a>
                        <a href="/message" class="nav_item">
                            <i class="iconfont icon-comment"></i>
                            <br>留言
                        </a>
                        <a href="/about" class="nav_item">
                            <i class="iconfont icon-info"></i>
                            <br>关于
                        </a>
                    </div>
                    <div class="contact">
                        <a href="https://github.com/tangxiangmin" target="_blank" class="contact_link">
                            <i class="iconfont icon-github"></i> GitHub</a>
                        <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=645234650&amp;site=qq&amp;menu=yes"
                            target="_blank" class="contact_link">
                            <i class="iconfont icon-qq"></i> QQ</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="tool">
        <div class="btn-list hide-md" id="J_toggleSide">
            <div class="btn-icon">
                <span class="btn-line"></span>
                <span class="btn-line"></span>
                <span class="btn-line"></span>
            </div>
        </div>
        <div class="btn-top">
            <i class="iconfont icon-top"></i>
        </div>
    </div>
</aside>
    <footer class="page_ft">
    <div class="container footer">
        <p>世人的悲欢并不相通，我只是觉得他们吵闹。</p>
        <p>
            Copyright © Shymean 2016 - 2017
            <a href="http://www.miitbeian.gov.cn" rel="nofollow" target="_blank" style="display:inline-block;">粤ICP备17060238号-1</a>
        </p>
    </div>
    <div class="hide-xs">
        <script src="https://s19.cnzz.com/z_stat.php?id=1264491168&amp;web_id=1264491168" language="JavaScript"></script>
    </div>
</footer>

</div>

</body>
</html>